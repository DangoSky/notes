<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>其他 | 略记一二</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="笔记记了是要常常翻出来看的，不然干嘛要花那么多时间记笔记？">
    <link rel="preload" href="/assets/css/0.styles.e11ec23d.css" as="style"><link rel="preload" href="/assets/js/app.e38833ea.js" as="script"><link rel="preload" href="/assets/js/2.17cbeac6.js" as="script"><link rel="preload" href="/assets/js/13.896ca89d.js" as="script"><link rel="prefetch" href="/assets/js/10.250fcf81.js"><link rel="prefetch" href="/assets/js/11.f157cd0b.js"><link rel="prefetch" href="/assets/js/12.a9bf3862.js"><link rel="prefetch" href="/assets/js/14.87494d07.js"><link rel="prefetch" href="/assets/js/15.f68977cd.js"><link rel="prefetch" href="/assets/js/16.b94738a9.js"><link rel="prefetch" href="/assets/js/17.e2c75320.js"><link rel="prefetch" href="/assets/js/18.771a5ec2.js"><link rel="prefetch" href="/assets/js/19.d49b8edf.js"><link rel="prefetch" href="/assets/js/20.555d276b.js"><link rel="prefetch" href="/assets/js/21.e44090be.js"><link rel="prefetch" href="/assets/js/22.097d6f98.js"><link rel="prefetch" href="/assets/js/23.4b3259b7.js"><link rel="prefetch" href="/assets/js/24.3c89c6ed.js"><link rel="prefetch" href="/assets/js/25.f67fd8aa.js"><link rel="prefetch" href="/assets/js/26.884593de.js"><link rel="prefetch" href="/assets/js/27.0564c2cb.js"><link rel="prefetch" href="/assets/js/28.e1a2c4d8.js"><link rel="prefetch" href="/assets/js/29.1ebfe2ec.js"><link rel="prefetch" href="/assets/js/3.dac61e26.js"><link rel="prefetch" href="/assets/js/30.8c4ee977.js"><link rel="prefetch" href="/assets/js/31.8986c831.js"><link rel="prefetch" href="/assets/js/32.4b30f57a.js"><link rel="prefetch" href="/assets/js/33.b9a4cf5e.js"><link rel="prefetch" href="/assets/js/34.776e490e.js"><link rel="prefetch" href="/assets/js/35.9bdcf90b.js"><link rel="prefetch" href="/assets/js/36.b5932fba.js"><link rel="prefetch" href="/assets/js/37.df17cf67.js"><link rel="prefetch" href="/assets/js/38.3d8b4eda.js"><link rel="prefetch" href="/assets/js/39.b3be75c3.js"><link rel="prefetch" href="/assets/js/4.b0dc7c39.js"><link rel="prefetch" href="/assets/js/40.96fd608f.js"><link rel="prefetch" href="/assets/js/41.0513a23b.js"><link rel="prefetch" href="/assets/js/42.6cd3cc53.js"><link rel="prefetch" href="/assets/js/43.5ef51692.js"><link rel="prefetch" href="/assets/js/44.794100ff.js"><link rel="prefetch" href="/assets/js/45.d10168fa.js"><link rel="prefetch" href="/assets/js/46.10688120.js"><link rel="prefetch" href="/assets/js/47.094c2cd3.js"><link rel="prefetch" href="/assets/js/48.95a26822.js"><link rel="prefetch" href="/assets/js/49.41c75b8f.js"><link rel="prefetch" href="/assets/js/5.c61e0a12.js"><link rel="prefetch" href="/assets/js/50.06594e41.js"><link rel="prefetch" href="/assets/js/51.4227a338.js"><link rel="prefetch" href="/assets/js/52.b756be3f.js"><link rel="prefetch" href="/assets/js/53.0d45f222.js"><link rel="prefetch" href="/assets/js/54.a37e137d.js"><link rel="prefetch" href="/assets/js/55.81a19fae.js"><link rel="prefetch" href="/assets/js/56.800ff698.js"><link rel="prefetch" href="/assets/js/57.70844d0c.js"><link rel="prefetch" href="/assets/js/58.f750a736.js"><link rel="prefetch" href="/assets/js/59.46a720cc.js"><link rel="prefetch" href="/assets/js/6.b167fa87.js"><link rel="prefetch" href="/assets/js/60.281e7077.js"><link rel="prefetch" href="/assets/js/61.03db5b64.js"><link rel="prefetch" href="/assets/js/62.3ef279a6.js"><link rel="prefetch" href="/assets/js/63.58d1689f.js"><link rel="prefetch" href="/assets/js/64.691b77a9.js"><link rel="prefetch" href="/assets/js/65.aea71ebe.js"><link rel="prefetch" href="/assets/js/66.fdcb5c4c.js"><link rel="prefetch" href="/assets/js/67.3851f01d.js"><link rel="prefetch" href="/assets/js/68.eff1c7f3.js"><link rel="prefetch" href="/assets/js/69.b97074c2.js"><link rel="prefetch" href="/assets/js/7.092eb31d.js"><link rel="prefetch" href="/assets/js/70.7525968a.js"><link rel="prefetch" href="/assets/js/71.fdc9d9ba.js"><link rel="prefetch" href="/assets/js/72.e699fc43.js"><link rel="prefetch" href="/assets/js/73.a075b568.js"><link rel="prefetch" href="/assets/js/74.ad5edd6a.js"><link rel="prefetch" href="/assets/js/75.fcf08968.js"><link rel="prefetch" href="/assets/js/76.0fcbd3a7.js"><link rel="prefetch" href="/assets/js/77.1b7c112c.js"><link rel="prefetch" href="/assets/js/78.0aa2e0c8.js"><link rel="prefetch" href="/assets/js/79.036605dc.js"><link rel="prefetch" href="/assets/js/8.6636c5ea.js"><link rel="prefetch" href="/assets/js/80.2c62bfcb.js"><link rel="prefetch" href="/assets/js/81.3c52e5ef.js"><link rel="prefetch" href="/assets/js/82.541ed7c1.js"><link rel="prefetch" href="/assets/js/83.db9e79cf.js"><link rel="prefetch" href="/assets/js/9.71cb8be9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e11ec23d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">略记一二</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="http://blog.dangosky.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/DangoSky" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="http://blog.dangosky.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/DangoSky" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JavaScript/其他.html" class="active sidebar-link">其他</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#数组-api-整理" class="sidebar-link">数组 api 整理</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#js-数据" class="sidebar-link">JS 数据</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#dom-相关" class="sidebar-link">DOM 相关</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#reflect" class="sidebar-link">Reflect</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#离线缓存-manifest" class="sidebar-link">离线缓存 manifest</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#装饰器" class="sidebar-link">装饰器</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#正则表达式" class="sidebar-link">正则表达式</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#图片懒加载实现方式" class="sidebar-link">图片懒加载实现方式</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#pwa" class="sidebar-link">PWA</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#intelligence" class="sidebar-link">Intelligence</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#经典问题" class="sidebar-link">经典问题</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#几个框架" class="sidebar-link">几个框架</a></li><li class="sidebar-sub-header"><a href="/JavaScript/其他.html#service-worker" class="sidebar-link">Service Worker</a></li></ul></li><li><a href="/JavaScript/DOM属性计算.html" class="sidebar-link">DOM 属性计算</a></li><li><a href="/JavaScript/this.html" class="sidebar-link">this</a></li><li><a href="/JavaScript/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/JavaScript/Iterator和Generator.html" class="sidebar-link">Iterator 和 Generator</a></li><li><a href="/JavaScript/async.html" class="sidebar-link">async</a></li><li><a href="/JavaScript/网络.html" class="sidebar-link">网络</a></li><li><a href="/JavaScript/模块化.html" class="sidebar-link">模块化</a></li><li><a href="/JavaScript/Storage.html" class="sidebar-link">浏览器存储</a></li><li><a href="/JavaScript/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/JavaScript/内存管理.html" class="sidebar-link">内存管理</a></li><li><a href="/JavaScript/疑难杂症.html" class="sidebar-link">疑难杂症</a></li><li><a href="/JavaScript/WebSocket.html" class="sidebar-link">WebSocket</a></li><li><a href="/JavaScript/OAuth.html" class="sidebar-link">OAuth</a></li><li><a href="/JavaScript/cookie和session.html" class="sidebar-link">Cookie 、 Session 和 Token</a></li><li><a href="/JavaScript/网页性能.html" class="sidebar-link">网页性能</a></li><li><a href="/JavaScript/小程序.html" class="sidebar-link">小程序</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React-Route</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mobx</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h1> <h2 id="数组-api-整理"><a href="#数组-api-整理" class="header-anchor">#</a> 数组 api 整理</h2> <h4 id="改变原数组的方法"><a href="#改变原数组的方法" class="header-anchor">#</a> 改变原数组的方法</h4> <ul><li>splice</li></ul> <p>如果只有一个参数，等同于将原数组在指定位置拆分成两个数组，并返回被删除的元素。<code>[1,2,3,4].splice(2) // [3, 4]</code></p> <ul><li>sort</li></ul> <p>若比较函数返回值 &lt;0，a 在前。若比较函数返回值&gt; 0，b 在前。会 <strong>返回一个到数组本身的引用</strong>，后续对其中一个数组的操作会修改到两个。</p> <ul><li><p>pop</p></li> <li><p>shift</p></li></ul> <p>删除后返回这一个元素，上同</p> <ul><li><p>push</p></li> <li><p>unshift</p></li></ul> <p>添加一个或多个元素，并返回数组长度，上同</p> <ul><li><p>reverse 会<strong>返回一个到数组本身的引用</strong>。</p></li> <li><p>copyWithin(target, start, end)</p></li></ul> <p>将 start 到 end 位置之间的字符复制到 target 位上，读了几个元素就从开始被替换的地方替换几个元素。<strong>会返回一个到数组本身的引用</strong>。</p> <ul><li>fill(val, start, end)</li></ul> <p>用 val 填充 start 到 end 之间的字符，会代替原先位置上的字符。如果要填充的字符是引用类型，则 <strong>被填充的几个元素都是引用同一个地址</strong>，即对其中一个的操作会修改到其他几个。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment">// [{}, {}, {}];</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>hi <span class="token operator">=</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">;</span>              <span class="token comment">// [{ hi: &quot;hi&quot; }, { hi: &quot;hi&quot; }, { hi: &quot;hi&quot; }]</span>

<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// [[], [], []]</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// [[5], [5], [5]]</span>
</code></pre></div><h4 id="不改变原数组的方法"><a href="#不改变原数组的方法" class="header-anchor">#</a> 不改变原数组的方法</h4> <ul><li>slice</li></ul> <p><code>Array.prototype.slice.call({0: 'a', 1: 'b', length: 2}) // ['a', 'b']</code></p> <ul><li><p>concat</p></li> <li><p>flat(deep）</p></li></ul> <p>返回一个新数组，不改变原数组。会移除数组中的空项。 <code>[1,2,,,].flat() // [1, 2]</code></p> <ul><li>flatMap()</li></ul> <p>对每个成员执行一个函数（相当于 map()），然后对返回值组成的数组执行 flat() 方法。该方法同样返回一个新数组，不改变原数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()  -&gt; [2, 4, 3, 6, 4, 8]</span>
<span class="token comment">// flatMap() 只能展开一层数组。</span>
</code></pre></div><h4 id="foreach"><a href="#foreach" class="header-anchor">#</a> forEach</h4> <ul><li><p>特性</p> <ul><li>无法中途退出循环，只能用 return 退出本次回调，进行下一次回调。</li> <li>对于已在迭代过程中删除的元素，或者空元素会跳过回调函数 (对于 undefined 和 null 则不会跳过)</li> <li>遍历次数在第一次循环前就会确定，再添加到数组中的元素不会被遍历。</li></ul></li> <li><p>对于空数组，some 方法返回 false，every 方法返回 true，回调函数都不会执行。</p></li></ul> <h4 id="数组空位"><a href="#数组空位" class="header-anchor">#</a> 数组空位</h4> <p>数组的空位指，数组的某一个位置没有任何值。空位不是 undefined，一个位置的值等于 undefined，依然是有值的。空位是没有任何值，in 运算符可以说明这一点 (in 查找不到空位)。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span>     <span class="token comment">// true</span>
<span class="token number">0</span> <span class="token keyword">in</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// false， 相当于 [, , ,]</span>
</code></pre></div><h2 id="js-数据"><a href="#js-数据" class="header-anchor">#</a> JS 数据</h2> <h4 id="原始数据"><a href="#原始数据" class="header-anchor">#</a> 原始数据</h4> <ul><li><p>原始类型的值可以自动当作包装对象调用，即调用包装对象的属性和方法。这时 JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。比如，字符串可以调用 length 属性。<strong>自动转换生成的包装对象是只读的</strong>，无法修改。所以，字符串无法添加新属性。这意味着下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象 String.prototype 上定义。</p></li> <li><p>基本数据类型的值不可变，动态修改后原始值也是不变的，如修改字符串某一位上的字符并不会改变原字符串，而是返回一个新的基本类型。</p></li> <li><p>进制转换：</p> <ul><li>十进制转为其他进制：<code>(17).toString(16)</code>。把十进制的 17 转为十六进制。</li> <li>其他进制转为十进制：<code>parseInt(11, 16)</code>。把 11 当做十六进制看待，解析成十进制。</li></ul></li></ul> <h4 id="操作符的优先级"><a href="#操作符的优先级" class="header-anchor">#</a> 操作符的优先级</h4> <p><img src="/assets/img/4.fdd5a071.png" alt=""></p> <h4 id="let"><a href="#let" class="header-anchor">#</a> let</h4> <ul><li>在程序或者函数的顶层，let 和 const 并不会像 var 一样在全局对象上创造一个属性。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;global&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>

<span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>let 的变量提升和暂时性死区。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> temp <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 如果 let 有变量提升的话，temp 应该打印出 undefined，但并没有，说明没有变量提升。而按 var 的规则，此时 temp 可以向上层作用域获取到 22，但也没有，说明 let 声明的变量存在暂时性死区。</span>
</code></pre></div><h2 id="dom-相关"><a href="#dom-相关" class="header-anchor">#</a> DOM 相关</h2> <ul><li><p>为什么说操作 DOM 慢：</p> <ul><li>操作 DOM 可能会引起页面的重绘重排。</li> <li>操作 DOM 更新 UI，可能涉及到 JS 线程和 GUI 线程的通信，并且这两个线程是互斥的。</li></ul></li> <li><p>textContent 和 innerText：</p> <ul><li>textContent 会获取所有元素的内容，包括 <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 元素，然而 innerText 不会。</li> <li>innerText 不会返回隐藏元素的文本，而 textContent 会。</li> <li>innerText 受 CSS 样式的影响所以会触发重排，而 textContent 不会。</li></ul></li> <li><p>控制台打印使用不同的颜色：</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'\x1B[32m%s\x1B[0m'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'\x1B[31m%s\x1B[0m'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="节点操作"><a href="#节点操作" class="header-anchor">#</a> 节点操作</h4> <ul><li>在 targetElement 后面插入一个节点，targetElement 和新节点是兄弟节点关系。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">insertAfter</span><span class="token punctuation">(</span><span class="token parameter">newElement<span class="token punctuation">,</span> targetElement</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token keyword">var</span> parent <span class="token operator">=</span> targetElement<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>
  <span class="token comment">// 如果目标节点已经是最后一个元素，那么直接添加即可</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>targetElement <span class="token operator">===</span> parent<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span><span class="token punctuation">{</span>
    parent<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//否则，在当前节点的下一个节点之前添加</span>
    parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newElement<span class="token punctuation">,</span>targetElement<span class="token punctuation">.</span>nextSibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="mutationobserver-观测-dom-节点变化"><a href="#mutationobserver-观测-dom-节点变化" class="header-anchor">#</a> <code>MutationObserver</code> 观测 DOM 节点变化</h4> <blockquote><p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener noreferrer">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></blockquote> <p>使用 <code>new MutationObserver()</code> 创建一个 <code>MutationObserver</code> 对象，并传入一个回调函数可在 DOM 节点发生相应变化时触发。实例化出来的 <code>MutationObserver</code> 对象有三个方法：<code>disconnect</code>、<code>observe</code>、<code>takeRecords</code>。</p> <p>使用 <code>mutationObserver.observe(target[, options])</code> 可以监测某一个 DOM 节点，常用的配置选项有：<code>childList</code> 表示是否监测 DOM 节点的子孙节点，默认为 false；<code>attributes</code> 表示是否监测 DOM 节点的属性变换，默认也为 false。<code>subtree</code> 表示是否将监视范围扩展至目标节点整个节点树中的所有节点，默认也为 false。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> targetNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'some-id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> config <span class="token operator">=</span> <span class="token punctuation">{</span> attributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> childList<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> subtree<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Callback function to execute when mutations are observed</span>
<span class="token keyword">var</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">mutationsList</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> mutation <span class="token keyword">of</span> mutationsList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutation<span class="token punctuation">.</span>type <span class="token operator">==</span> <span class="token string">'childList'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A child node has been added or removed.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mutation<span class="token punctuation">.</span>type <span class="token operator">==</span> <span class="token string">'attributes'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The '</span> <span class="token operator">+</span> mutation<span class="token punctuation">.</span>attributeName <span class="token operator">+</span> <span class="token string">' attribute was modified.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>targetNode<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
observer<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h2> <ul><li>作用
<ul><li>规范化方法分类。将 Object 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty</code>），放到 Reflect 对象上。</li> <li>修改某些 Object 方法的返回结果，让其变得更合理。比如 <code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时，会抛出一个错误，而 <code>Reflect.defineProperty(obj, name, desc)</code> 则会返回 false。</li> <li>让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code>，而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为。</li> <li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法。</li></ul></li></ul> <h2 id="离线缓存-manifest"><a href="#离线缓存-manifest" class="header-anchor">#</a> 离线缓存 manifest</h2> <ul><li><p>介绍：在 manifest 文件中定义那些需要缓存的文件，支持 manifest 的浏览器将按照 manifest 文件的规则将文件保存在本地，从而在没有网络链接的情况下，也能访问页面。我们第一次正确配置 app cache 后，当再次访问该应用时，浏览器会首先检查 manifest 文件是否有变动，如果有变动就会把相应的变动更新下来，同时改变浏览器里面的app cache；如果没有变动，就会直接把 app cache 的资源返回。</p></li> <li><p>特点：</p> <ul><li>离线浏览：用户可以在离线状态下浏览网站内容。</li> <li>更快的速度：因为数据被存储在本地，所以速度会更快.</li> <li>减轻服务器的负载：浏览器只会下载在服务器上发生改变的资源。</li> <li>相比于浏览器会自动缓存 Http 请求的内容，manifest 可以缓存没有被访问到的内容。</li></ul></li> <li><p>使用： <code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></p></li> <li><p>文件格式</p></li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>CACHE MANIFEST  <span class="token comment"># 固定格式，必须写在前面</span>
<span class="token comment"># version 1.3</span>

<span class="token comment"># 必须字段，标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径，无法使用通配符 *。</span>
CACHE:
  test.css

<span class="token comment"># 可选，表示永远不会被缓存的文件，可以使用通配符 ＊。</span>
NETWORK:
	*

<span class="token comment"># 可选，表示当资源无法访问时，使用指定的后备资源来替代。每条记录都列出两个 url，第一个表示当前页面，第二个表示后备页面，都必须使用相对路径</span>
FALLBACK:
  /html5/ /404.html
  *.html /404.html
</code></pre></div><ul><li><p>更新缓存的方法：</p> <ul><li>更新 manifest 文件，比如可以修改版本号。</li> <li>通过 JS 操作。<code>window.applicationCache.update()</code> 会在每次打开页面时自动调用，去检查服务端有没有更新 manifest，我们也可以手动调用它来及时更新。</li> <li>清除浏览器缓存。</li></ul></li> <li><p>注意事项：</p> <ul><li>manifest 文件需要配置正确的 <code>MIME-type</code>，即 <code>text/cache-manifest</code>，必须在 web 服务器上进行配置。或者使用新的写法 <code>&lt;html manifest=&quot;index.appcache&quot;&gt;</code> 就不需要再进行服务端配置了。</li> <li>浏览器对缓存数据的容量限制可能不太一样，一些浏览器是每个站点 5MB。</li> <li>如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</li> <li>引用 manifest 的 HTML 文件必须与 manifest 文件同源，在同一个域下。</li> <li>FALLBACK 中的资源必须和 manifest 文件同源。</li> <li>站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</li> <li>（更推荐<a href="https://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/" target="_blank" rel="noopener noreferrer">使用 Service Worker 来做离线缓存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</li></ul></li> <li><p>manifest 在缓存静态文件的同时，也会默认缓存 HTML 文件。这导致页面的更新只能通过 manifest 文件中的版本号来决定。所以 manifest 缓存只适合那种常年不变化的静态网站（这也是它无人问津的原因）。</p></li></ul> <h2 id="装饰器"><a href="#装饰器" class="header-anchor">#</a> 装饰器</h2> <p>装饰器一般是用来装饰类、类属性、类方法。使用装饰器可以做到不直接修改代码，就实现某些功能。</p> <h4 id="类装饰器"><a href="#类装饰器" class="header-anchor">#</a> 类装饰器</h4> <p>装饰类的时候，装饰器方法一般会接收一个目标类作为参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 给目标类增加原型方法</span>
<span class="token keyword">const</span> <span class="token function-variable function">withSpeak</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">targetClass</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prototype <span class="token operator">=</span> targetClass<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  prototype<span class="token punctuation">.</span><span class="token function-variable function">speak</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I can speak '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>language<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

@withSpeak
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">language</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>language <span class="token operator">=</span> language<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> student1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">'Chinese'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
student1<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// I can speak  Chinese</span>
</code></pre></div><p>利用高阶函数的属性，还可以给装饰器传参，通过参数来判断对类进行什么处理。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 返回一个函数，当做新的装饰器函数来装饰 Student 类（类似于函数柯里化）</span>
<span class="token keyword">const</span> <span class="token function-variable function">withLanguage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">language</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">targetClass</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  targetClass<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>language <span class="token operator">=</span> language<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

@<span class="token function">withLanguage</span><span class="token punctuation">(</span><span class="token string">'Chinese'</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
student<span class="token punctuation">.</span>language<span class="token punctuation">;</span> <span class="token comment">// 'Chinese'</span>
</code></pre></div><h4 id="类属性装饰器"><a href="#类属性装饰器" class="header-anchor">#</a> 类属性装饰器</h4> <p>类属性装饰器可以用在类的属性、方法、get/set 函数中，一般会接收三个参数：target 表示被修饰的类、name 表示类成员的名字、descriptor 表示属性描述符（对象会将这个参数传给 <code>Object.defineProperty</code> 以此修饰 target 类）。使用类属性装饰器可以实现将类属性设置为只读（设置 <code>descriptor.writable = false</code>），或者统计一个函数的执行时间。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> descriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> func <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> func <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    descriptor<span class="token punctuation">.</span><span class="token function-variable function">value</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> results<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  @time
  <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="装饰器的应用"><a href="#装饰器的应用" class="header-anchor">#</a> 装饰器的应用</h4> <ol><li><p>例如 <a href="https://github.com/jayphelps/core-decorators" target="_blank" rel="noopener noreferrer"><code>core-decorators.js</code> 库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，常用在 React 中绑定类的 this。此外还有防抖和节流，简化了不少代码。</p></li> <li><p>实现多重继承。</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// targetClass 继承了 mixins 中的所有类</span>
<span class="token keyword">const</span> <span class="token function-variable function">mixin</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>mixins</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">targetClass</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  mixins <span class="token operator">=</span> <span class="token punctuation">[</span>targetClass<span class="token punctuation">,</span> <span class="token operator">...</span>mixins<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> source</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> <span class="token string">'constructor'</span>
        <span class="token operator">&amp;&amp;</span> key <span class="token operator">!==</span> <span class="token string">'prototype'</span>
        <span class="token operator">&amp;&amp;</span> key <span class="token operator">!==</span> <span class="token string">'name'</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> desc <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">class</span> <span class="token class-name">Mixin</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> mixin <span class="token keyword">of</span> mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">mixin</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝实例属性</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> mixin <span class="token keyword">of</span> mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">copyProperties</span><span class="token punctuation">(</span>Mixin<span class="token punctuation">,</span> mixin<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝静态属性</span>
    <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token class-name">Mixin</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> mixin<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝原型属性</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Mixin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>用来对类的属性进行类型的校验。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> rules <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'string'</span><span class="token punctuation">,</span>
  password<span class="token operator">:</span> <span class="token string">'string'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token string">'number'</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对 targetClass 类中的各个属性按 rules 进行类型校验</span>
<span class="token keyword">const</span> <span class="token function-variable function">validator</span> <span class="token operator">=</span> <span class="token parameter">rules</span> <span class="token operator">=&gt;</span> <span class="token parameter">targetClass</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">newProxy</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">construct</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">target</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> type<span class="token punctuation">]</span> <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>rules<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">!==</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">thrownewError</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> must be </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

@<span class="token function">validator</span><span class="token punctuation">(</span>rules<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">'tom'</span>
  password <span class="token operator">=</span> <span class="token string">'123'</span>
  age <span class="token operator">=</span> <span class="token string">'21'</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h2> <ul><li><code>[xyz]</code>	字符集合。匹配所包含的任意一个字符。</li> <li><code>[^xyz]</code> 负值字符集合。匹配未包含的任意字符。</li> <li><code>[^a-z]</code> 负值字符范围。匹配任何不在指定范围内的任意字符。</li> <li><code>.</code>	匹配除 <code>\n</code> 之外的任何单个字符。</li> <li><code>\d</code> 匹配一个数字字符。等价于 <code>[0-9]</code>。</li> <li><code>\D</code> 匹配一个非数字字符。等价于 <code>[^0-9]</code>。</li> <li><code>\s</code> 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code>。</li> <li><code>\S</code> 匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</li> <li><code>\w</code> 匹配包括下划线的任何单词字符。等价于 <code>[A-Za-z0-9_]</code>。</li> <li><code>\W</code> 匹配任何非单词字符。等价于 <code>[^A-Za-z0-9_]</code>。</li> <li><code>\b</code> 匹配一个单词边界，也就是指单词和空格间的位置。<code>er\b</code> 可以匹配 <code>never</code> 中的 <code>er</code>，但不能匹配 <code>verb</code> 中的 <code>er</code>。</li> <li><code>\B</code> 匹配非单词边界。<code>er\B</code> 能匹配 <code>verb</code> 中的 <code>er</code>，但不能匹配 <code>never</code> 中的 <code>er</code>。</li> <li><code>-?[0-9]+(\\.[0-9]*)?</code> 验证是否为数字（是否带小数点、正负都行）。</li></ul> <h4 id="反斜杠"><a href="#反斜杠" class="header-anchor">#</a> 反斜杠</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">&quot;rgb(51, 112, 255)&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;rgb\(51, 112, 255\)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;g&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 匹配不到，输出为 null</span>

<span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">&quot;rgb(51, 112, 255)&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;rgb\\(51, 112, 255\\)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;g&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这样就可以匹配到了</span>
</code></pre></div><p>第一个例子匹配不到的原因在于，字符串里的 <code>\</code> 并不表示单纯的 <code>\</code> 字符，它有特殊意义，用于转义它后面的字符，所以 <code>new RegExp(&quot;rgb\(51, 112, 255\)&quot;, &quot;g&quot;)</code> 被翻译成了 <code>/rgb(51, 112, 255)/g</code>，这里的 <code>()</code> 具有特殊含义，所以匹配不到。</p> <p>所以需要用 <code>\\</code> 来将字符串中的 <code>\</code> 转义为单纯的 <code>\</code> 字符，这样就翻译成了 <code>/rgb\(51, 112, 255\)/g</code>，就可以转义括号了，也就能正常匹配到了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'\\\\'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// \\</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'\\\\'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [ '\\', '\\' ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/\\/g</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [ '\\', '\\' ]</span>
</code></pre></div><h4 id="和"><a href="#和" class="header-anchor">#</a> ?= 和 ?!</h4> <p><code>exp1(?=exp2)</code>：查找 exp2 前面的 exp1。</p> <p><code>(?&lt;=exp2)exp1</code>：查找 exp2 后面的 exp1。</p> <p><code>exp1(?!exp2)</code>：查找后面不是 exp2 的 exp1。</p> <p><code>(?&lt;!exp2)exp1</code>：查找前面不是 exp2 的 exp1。</p> <h2 id="图片懒加载实现方式"><a href="#图片懒加载实现方式" class="header-anchor">#</a> 图片懒加载实现方式</h2> <h4 id="监听-scroll"><a href="#监听-scroll" class="header-anchor">#</a> 监听 scroll</h4> <p>先不设置图片的 src（是不设置而不是值设置为空字符串，设置为空字符串的话还是会发起一个 HTTP 请求），或者将其设置为 loading 的图片，而真实的图片 url 设置在 <code>data-src</code> 中。监听 scroll 事件，当图片节点出现在视图中时，就将 src 的值设置为 <code>data-src</code> 的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 判断图片是否出现在视图中</span>
<span class="token keyword">var</span> clientHeight <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>
<span class="token keyword">var</span> scrollTop <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>
<span class="token comment">// 或者通过 getBoundingClientRect 判断</span>
<span class="token comment">// 当 el.getBoundingClientRect().top &lt;= window.innerHeight 时，图片就出现在视图中了</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>offsetTop <span class="token operator">&lt;</span> clientHeight <span class="token operator">+</span> scrollTop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'images/loading.gif'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    img<span class="token punctuation">.</span>src <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'data-src'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>优化点：
<ul><li>因为滚动页面时，scroll 的监听函数触发频率很大，所以最好加个防抖操作。</li> <li>在 scroll 事件中，需要获取到页面中所有的 <code>&lt;img&gt;</code> 标签，每次触发回调时都要去遍历这个 img 数组，可以用一个变量标志数组中哪个下标的图片已经加载了，避免每次都从头遍历数组。</li></ul></li></ul> <h4 id="intersectionobserver-api"><a href="#intersectionobserver-api" class="header-anchor">#</a> IntersectionObserver API</h4> <p>使用 <code>IntersectionObserver</code> 这个 API 来自动实现懒加载。</p> <blockquote><p>参考 <a href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener noreferrer">IntersectionObserver API 使用教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// items 是一个数组，包含了被观察的并且可见性发生变化的节点，当节点的可见性发生变化时就会调用该回调函数</span>
<span class="token keyword">const</span> io <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">items</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> target <span class="token operator">=</span> item<span class="token punctuation">.</span>target<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'images/loading.gif'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      target<span class="token punctuation">.</span>src <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'data-src'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

imgDomArr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">img</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 添加要观察的 DOM 节点</span>
  io<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="pwa"><a href="#pwa" class="header-anchor">#</a> PWA</h2> <ul><li>简介：渐进式网页应用，集成了网页和 native app 的一些特点，包括：
<ul><li>可以通过 url 分享。</li> <li>内容可以被搜索引擎搜索到。</li> <li>可以出现在设备的主屏幕而不用借助于浏览器，有利用增强用户粘性。</li> <li>可以在离线状态下运行（通过 Service Worker 实现的）。</li> <li>可以向设备发送通知。</li> <li>不用像 app 那样需要安装和更新，只需要刷新页面就可以了。</li></ul></li></ul> <h2 id="intelligence"><a href="#intelligence" class="header-anchor">#</a> Intelligence</h2> <blockquote><p>这里记录一些对智力题的思考过程。不想再单独开一个菜单项了，就直接放这吧~</p></blockquote> <blockquote><p>更多智力题参考<a href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E7%AE%97%E6%B3%95/%E6%99%BA%E5%8A%9B%E9%A2%98.md" target="_blank" rel="noopener noreferrer">常见面试智力题总结<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h4 id="取余制胜"><a href="#取余制胜" class="header-anchor">#</a> 取余制胜</h4> <p>Q：A 和 B 轮流拿硬币，每次最多只能拿 n 个，A 先手，怎么才可以拿到最后一个硬币？</p> <p>A：A 要拿到最后一个，则需要在他倒数第二次拿的时候还剩 n+1 个硬币，这样无论 B 怎么拿 A 总能拿到最后一个。所以需要保证每轮 A 和 B 拿的硬币数量都是 n+1 的整数倍，也就是第一次拿的时候 A 要拿 <code>n % (n+1)</code> 个硬币，之后每次 B 拿多少个硬币，A 就拿相应的数量使两者之和凑到 n+1 即可。</p> <p>思路总结：从后往前推，确定最后剩下多少个硬币时自己一定会获胜，然后再制定相应的策略。</p> <h4 id="n-匹马比赛求最后的前几名"><a href="#n-匹马比赛求最后的前几名" class="header-anchor">#</a> n 匹马比赛求最后的前几名</h4> <p>Q：36 匹马分别在 6 个赛道比赛，每次比赛只知道名次而不知道具体的用时，如何快速决出前三名？</p> <p>A：分三轮比赛：</p> <p>第一轮：36 匹马分 6 组比赛，分别得到每场的第一名，6 组比赛分别按名次记为 A1、B1、C1、D1、E1、F1、A2、B2...</p> <p>第二轮：A1、B1、C1、D1、E1、F1 进行比赛，得到前三名假如是 A1、B1、C1。结果只要前三名，所以已经可以排除掉所有 D、E、F 马匹了（D1、E1、F1 都没拿到前三，它们后面的自然也拿不到）。又因为 A1 已经连续两次第一，所以 A1 就是冠军了，此时只剩两个名额。而 C1 最好的成绩也只是第三名，所以 C2 和 C3 也可以排除掉了。</p> <p>第三轮：现在只剩下 A2、A3、B1、B2、C1，进行一轮比赛可得到最后的季军和亚军。至此，前三名已经得到了，总共比赛次数是 6 + 1 + 1 = 8 次。</p> <h4 id="时针分针形成的角度"><a href="#时针分针形成的角度" class="header-anchor">#</a> 时针分针形成的角度</h4> <p>Q：当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？</p> <p>A：每小时时针走的度数是 30°（<code>360 / 12</code>），每分钟分针走的度数是 6°（<code>360 / 60</code>），而每分钟时针走的度数是 0.5°（<code>30 / 60</code>）。所以 m 点 n 分时，时针走了 <code>30 * m + 0.5 * m</code>，分针走了 <code>6 * n</code>，它们的夹角是 <code>|30 * m - 5.5 * n|</code>。但因为小时可能为 24 小时制，所以 m 需要去对 12 取余；以及形成的夹角可能是更大的那个，所以还需要再判断取小的那个。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">angleClock</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">hour<span class="token punctuation">,</span> minutes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  hour <span class="token operator">=</span> hour <span class="token operator">%</span> <span class="token number">12</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">*</span> hour <span class="token operator">-</span> <span class="token number">5.5</span> <span class="token operator">*</span> minutes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">360</span> <span class="token operator">-</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>如果给的是特殊时间，需要随机应变想到更灵活的解法。比如 06:15 的时针分针夹角。这时候再去推断公式会比较慢，可以这么想：假如时针没有随着分针移动，那么两者之间夹角为 90°。而每分钟时针走的度数是 0.5°，所以 15 分钟里时针随分针走了 7.5°，即 06:15 的时候分针和时针的夹角是 97.5°。这样想是不是就快很多了。Orz，腾讯一面的时候问到这道题，我推论出公式后回答了，面试面试官说我想得太复杂，就告诉我这种解法。</p> <h4 id="同时满足条件的占比"><a href="#同时满足条件的占比" class="header-anchor">#</a> 同时满足条件的占比</h4> <p>Q：一个班级 60% 喜欢足球，70% 喜欢篮球，80% 喜欢排球，问即三种球都喜欢占比有多少？</p> <p>A：最多时有 60% 的人三种球都喜欢。根据题目可以知道有 40% 的人不喜欢足球，30% 的人不喜欢篮球，20% 的人不喜欢排球。所以最少的情况下，这里的 40%、30%、20% 中的人没有重复的，也就有 100% - 40% - 30% - 20% = 10% 的人都喜欢三种球。因此三种球都喜欢的人的占比为 10%-60%。</p> <h4 id="三扇门选择正确的那扇"><a href="#三扇门选择正确的那扇" class="header-anchor">#</a> 三扇门选择正确的那扇</h4> <p>Q：有三扇门 a、b、c，其中只有一扇门是正确的。路人甲打算选择 a 门，而路人乙明确指出另外两扇门中其中一扇是错误的，并且路人乙没有说谎。问路人甲应该更换选择的门吗？</p> <p>A：分三种情况讨论：</p> <ol><li><p>a 门是正确的，路人乙指出 b 或 c 是错误的。那么如果路人甲换门的话，会选错。</p></li> <li><p>b 门是正确的，路人乙指出 c 门是错误的。那么如果路人甲换门的话，会选对。</p></li> <li><p>c 门是正确的，路人乙指出 b 门是错误的。那么如果路人甲换门的话，会选对。</p></li></ol> <p>所以换门后选对的概率是三分之二，选错的概率是三分之一，也就是路人甲应该换门。</p> <h4 id="四个瓶子找重量不同的那罐"><a href="#四个瓶子找重量不同的那罐" class="header-anchor">#</a> 四个瓶子找重量不同的那罐</h4> <p>Q：四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</p> <p>A：通过控制药片的数量改变总重量来判断。首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4 片药片。将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</p> <h4 id="八个球找重量不同的那个"><a href="#八个球找重量不同的那个" class="header-anchor">#</a> 八个球找重量不同的那个</h4> <p>Q：假设你有 8 个球，其中一个略微重一些，找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？</p> <p>A：最少两次可以称出。首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</p> <h4 id="握手次数"><a href="#握手次数" class="header-anchor">#</a> 握手次数</h4> <p>Q：五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A 问了其他人，发现每个人的握手次数都不同，那么 A 的配偶握手了几次？</p> <p>A：每个人最多只能和 8 个人握手，又每个人的握手次数都不同，所以总共有 9 种握手情况，握手次数分别为 0、1、2、3、4、5、6、7、8 这九种情况。握了 8 次手的人，只有和自己、他的配偶没握手，所以可以推断出握了 0 次手的人是握了 8 次手的人的配偶。握了 7 次手的人，只有和自己、他的配偶、握了 0 次手的人没握手，所以可以推断出握了 1 次手的人是握了 7 次手的人的配偶。同理可推断握了 6 次手和握了 2 次手的人、握了 5 次手和握了 3 次手的人是配偶。所以 A、A 的配偶都和他人握了 4 次手。</p> <h4 id="烧绳子计时"><a href="#烧绳子计时" class="header-anchor">#</a> 烧绳子计时</h4> <p>Q：烧一根不均匀的绳子要用一个小时，如何用它来判断一个小时十五分钟？</p> <p>A：一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。当 2 号绳子燃尽时，此时又过去了 15 分钟，此时再同时点燃 3 号绳子的 A、B 两端。当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</p> <h4 id="砝码称重"><a href="#砝码称重" class="header-anchor">#</a> 砝码称重</h4> <p>Q：有 7 克、2 克砝码各一个，天平一只，如何只用这些物品三次将 140 克的盐分成 50、90 克各一份？</p> <p>A：第一次用 7 克砝码和 2 克砝码称取 9 克盐。第二次再用第一次称取的盐和 7 克砝码称取 16 克盐。第三次再用前两次称取的盐称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</p> <h4 id="三个开关判断是控制哪盏灯"><a href="#三个开关判断是控制哪盏灯" class="header-anchor">#</a> 三个开关判断是控制哪盏灯</h4> <p>Q ：在房里有三盏灯，房外有三个开关，在房外看不见房内的情况并且只能进门一次，用什么方法来区分哪个开关控制哪一盏灯？</p> <p>A：首先打开一个开关，100 分钟后再打开第二个开关。之后进入房间看看哪两盏灯亮，摸摸亮的那两盏灯，发热的是第一个开关打开的，另一盏亮的灯是第二个开关打开的，剩下不亮的那盏灯就是第三个开关控制的。</p> <h4 id="识别三筐水果"><a href="#识别三筐水果" class="header-anchor">#</a> 识别三筐水果</h4> <p>Q：有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是错的。要求拿出其中一筐里的一只水果，然后正确写出三筐水果的标签。</p> <p>A：从贴了混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。将写了具体水果名字标签的其中一筐的标签改为另一种水果（因为它不会是混合水果，如果它是混合水果的话，另一筐水果贴的标签就是对的了）。剩下的那筐水果就是混合水果了。</p> <h2 id="经典问题"><a href="#经典问题" class="header-anchor">#</a> 经典问题</h2> <ul><li>this、作用域、优先级等综合考察：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Foo<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
 
<span class="token comment">//请写出以下输出结果：</span>
Foo<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Foo<span class="token punctuation">.</span>getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>解析参考<a href="https://mp.weixin.qq.com/s/X40KEH37cRj01a_AuTzKrw" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="几个框架"><a href="#几个框架" class="header-anchor">#</a> 几个框架</h2> <ul><li><p>共同的特性：</p> <ul><li>使用 Virtual DOM 来优化页面性能。</li> <li>组件化思想，使项目模块化，易于维护和组件复用。</li> <li>响应式的数据。实现数据改变了自动更新视图，数据驱动视图。</li> <li>只提供核心功能，其他的功能如路由、状态管理器等交给其他的库实现，使用户选择性更高。</li> <li>都支持服务器端渲染。</li> <li>都支持跨端开发，比如小程序和 APP。</li></ul></li> <li><p>为什么使用框架：</p> <ul><li>解决 UI 与状态同步的问题，这样开发者就可以着力于数据和逻辑的处理，而不需要管视图的更新。</li> <li>掩盖底层的 DOM 操作，使开发者可以使用更声明式的方式来描述目的，从而让代码更容易维护。</li> <li>页面组件化，易于维护。</li> <li>虚拟 DOM 的引入，使得不用频繁操作 DOM，提升了页面性能。</li> <li>一系列相关的生态库，比如路由和状态管理器，方便开发者使用。</li></ul></li></ul> <h4 id="react-和-vue"><a href="#react-和-vue" class="header-anchor">#</a> React 和 Vue</h4> <ul><li>区别：
<ul><li>JSX 和 Templates。JSX 使得编码更加自由，比如可以通过 JS 和临时变量来控制流程。对于条件判断、循环等，React 写起来就像是写 JS，Vue 则有特定的语法。（深层差别是 React 遵循的是 all in js 的思想，不管是 HTML 还是 CSS 都可以写在 JS 文件中）</li> <li>单向数据流和双向数据流。Vue 可以通过  <code>v-model</code> 来使视图的改变同步到数据，React 只有数据 -&gt; 视图这个单项的数据流。并且 Vue1.x 支持子组件修改 props，虽然 Vue2.x 开始不支持了，但也提供了 <code>.sync</code> 来支持子组件修改 props。</li> <li>数据绑定实现不同。Vue 是数据劫持；React 默认是通过比较引用的方式，通过 setState 来修改数据并更新视图。</li> <li>组件通信。Vue 实现子组件向父组件通信，是通过 emit 触发父组件的方法；React 是父组件将方法作为 props 传递给子组件，子组件再直接调用。</li> <li>语法糖。Vue 提供了 computed 和 watch 等语法糖供用户使用，React 则需要自己写逻辑实现。</li> <li>重新渲染。React 中当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树。而在 Vue 中，组件的依赖是在渲染的过程中自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染。</li></ul></li></ul> <h4 id="angular-的脏检查"><a href="#angular-的脏检查" class="header-anchor">#</a> Angular 的脏检查</h4> <ul><li><p>大致流程：</p> <ol><li>对于 UI 上的每个数据，都绑定一个 watch 对象（包含了变量名、监听函数会在值变化后返回新值、更新后的回调函数等属性），这些 watch 对象会被收集到 watchList 数组中。</li> <li>当事件触发时例如数据改变了，会执行一个 digest 函数去遍历 watchList，判断里面的每个属性有没有被更改过，如果数据改变了就记录下新值是多少。digest 函数遍历完毕之后，就知道哪些属性被更改过。</li> <li>再去遍历 scope 里面的所有属性查看有没有新添加的属性，如果 scope 里面更新了，会再次去循环遍历 watchList，直到没有数据更新为止，所以 digest 循环最少要遍历两次（最多执行 10 次，超过 10 次后抛出一个异常防止无限循环）。</li> <li>调用 apply 函数更新页面。</li></ol></li> <li><p>脏检查的优点是，当有批量数据更新时，脏检查可以批量更新 UI（等到所有 watch 都没有变化的时候再更新）。比如使用 for 循环向一个数组中 push 进很多个元素。如果是 Vue 的数据劫持的话，这时候每次 push 都会进行一次更新；而脏检查可以等到它都 push 完成后再进行更新。</p></li></ul> <h2 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h2> <ul><li><p>Service Worker 本质上也是浏览器缓存资源用的（例如 PWA），它基于 Web Worker，所以不会阻碍当前 JS 线程的执行。其最重要的工作原理就是：</p> <ul><li>后台线程：独立于当前网页线程。</li> <li>网络代理：在网页发起请求时代理，来缓存文件。</li></ul></li> <li><p>Service Worker 是基于 HTTPS 的，因为涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。如果是本地调试的话，localhost 也是可以的。</p></li> <li><p>Service Worker 工作的流程图</p></li></ul> <p><img src="/assets/img/9.9f4db19b.png" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/JavaScript/DOM属性计算.html">
        DOM 属性计算
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e38833ea.js" defer></script><script src="/assets/js/2.17cbeac6.js" defer></script><script src="/assets/js/13.896ca89d.js" defer></script>
  </body>
</html>
