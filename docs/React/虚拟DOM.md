# 虚拟 DOM

template/JSX -> Render Function -> Vnode（做 Diff）-> DOM

## 虚拟 DOM 的优势

- 非绝对上的速度优势。diff 算法比对虚拟 DOM 中需要变更的部分节点并更新，而非更新整个视图。不过如果整个 DOM 都更新了的话，使用虚拟 DOM 不仅一样要绘制渲染整个视图，而且还要进行 diff 算法，就不一定会更快了。

- 虚拟 DOM 只会在比对后修改一次真实 DOM，所以不会有大量的重排重绘消耗，而且可以只渲染局部。

- 使跨平台渲染成为可能。比如说 Node 里没有 DOM，如果想实现 SSR 的话，就可以借助虚拟 DOM，因为虚拟 DOM 本身只是一个 JavaScript 对象。而对于小程序和 APP，也可以用 JS 写虚拟 DOM 表示 UI，再由原生实现去渲染页面。


## 虚拟 DOM 的渲染流程

1. 将页面的真实 DOM 抽象成一个 JS 对象，包含了节点标签、节点的属性和子元素（所以其实虚拟 DOM 就只是一个 JS 对象）。

2. 数据改变时，将新的真实 DOM 抽象成另一个 JS 对象。

3. 采用深度优先遍历新旧两个虚拟 DOM，用一个唯一的 ID 标志每个节点，并比对两者的差别，将变化的类型、新值记录、节点 ID 记录在一个补丁数组里。节点的变化只有文本变化、属性变化、节点增删移动几种情况。

4. 根据补丁数组去修改需要更新的 DOM 节点。


## diff 算法

- diff 算法的优化：
  - 同级比对，只比较新旧虚拟 DOM 中同个层级的节点。
  - 同级相同节点位置变了可以复用（通过 key 来复用）。

- TODO：具体的 diff 流程和优化策略待日后补充。

## FAQ

1. 为什么使用深度优先遍历而不是广度优先遍历？

深度遍历使用到的是栈结构，深度遍历的时候，栈中保留的是当前节点的父元素和祖先元素，栈中存储的节点数就是树的深度值，占用的空间比较少。而广度遍历使用的是队列结构，广度遍历按树的层级来遍历，队列中保存的是下一层的节点，数量是树的广度值，占用的空间会更大。

2. diff 算法时间复杂度如何从 O(n^3) 优化到 O(n)？

原来的 diff 算法，是将旧虚拟 DOM 的每个节点和新虚拟 DOM 的每个节点进行比较，这就已经有 O(n^2) 了。但考虑到实际应用中跨层级的 DOM 节点改变很少，所以现在的 diff 算法只是比较同层级的节点，也就下降到了 O(n)。
