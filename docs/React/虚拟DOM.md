# 虚拟 DOM

## 使用虚拟 DOM 的渲染流程

1. 将页面的真实 DOM 抽象成一个 JS 对象，包含了节点标签、节点的属性和子元素（所以其实虚拟 DOM 就只是一个 JS 对象）。

2. 数据改变时，将新的真实 DOM 抽象成另一个 JS 对象。

3. 采用深度优先遍历比对新旧两个虚拟 DOM 的差别，并将变化的类型和新值记录在一个补丁数组里。节点的变化只有文本变化、属性变化、节点替换、节点增删移动几种情况。

4. 根据补丁数组去修改需要更新的 DOM 节点。


## diff 算法

- diff 算法的优化：
  - 同级比对，只比较新旧虚拟 DOM 中同个层级的节点。
  - 同级相同节点位置变了可以复用（通过 key 来复用）。

- TODO：具体的 diff 流程和优化策略待日后补充。

#### FAQ

1. 为什么使用深度优先遍历而不是广度优先遍历？

深度遍历使用到的是栈结构，深度遍历的时候，栈中保留的是当前节点的父元素和祖先元素，栈中存储的节点数就是树的深度值，占用的空间比较少。而广度遍历使用的是队列结构，广度遍历按树的层级来遍历，队列中保存的是下一层的节点，数量是树的广度值，占用的空间会更大。


## 虚拟 DOM 的优势

- 非绝对上的速度优势。diff 算法比对虚拟 DOM 中需要变更的部分节点并更新，而非更新整个视图。不过如果整个 DOM 都更新了的话，使用虚拟 DOM 不仅一样要绘制渲染整个视图，而且还要进行 diff 算法，就不一定会更快了。

- 虚拟 DOM 只会在比对后修改一次真实 DOM，所以不会有大量的重排重绘消耗，而且可以只渲染局部。

- 使跨平台渲染成为可能。比如说 Node 里没有 DOM，如果想实现 SSR 的话，就可以借助虚拟 DOM，因为虚拟 DOM 本身只是一个 JavaScript 对象。
