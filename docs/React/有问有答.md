# 有问有答

## 为什么自定义的组件首字母需要大写
  - jsx实际上是 react 使用 `React.createElement(component, props, children)` 创建组件/标签的。 components 的类型是 string（DOM标签）或 ReactClass（自定义组件），如果自定义的组件是小写开头，会被当作是DOM标签处理。

## 为什么要调用super：
  - 子类没有自己的this，是通过父类继承而来的。子类必须在constructor方法中调用super方法，从而得到父类的this对象，否则会报错。
  - 子类实例的构建，基于父类实例，只有super方法才能调用父类实例。

## super为什么要传props：
- 在构造函数被调用之后，会默认把props赋值给刚刚创建的实例对象（但在构造函数中无法使用到this.props）。

## 为什么事件需要绑定this：

事件处理函数作为回调传递后，丢失了上下文，导致this变成了undefined，所以需要绑定this。函数内部的 this 的值取决于该函数如何被调用。

## pureComponent和Component的区别
  - 对于pureComponent，当props或者state改变时，会先对新旧props和state进行浅对比，再决定是否执行shouldComponentUpdate。这里的浅比较是基本类型进行==判断，引用类型则只比较它们的引用是否相同。

  - 但使用PureCompoent要求满足如下条件：
    - props和state都必须是不可变对象，即基本数据类型（immutable object）。如果数据是引用类型，对属性的修改不会检测到。通过 immutable.js 可以使每个变化都会产生一个新的引用类型。
    - 如果数据改变无法反应在浅拷贝上，则应该调用forceUpdate来更新Component。
    - 一个PureComponent的子Component也应当是PureComponent。

## React.memo

跟 pureComponent 类似，用于函数组件。

```js
const TestC = React.memo（(props) => {
  console.log('Rendering TestC :', props)
  return ( 
      <div>
      { props.count }
      </>
  )
}）
```

## Immutable Data

对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是：使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。参考[这里](https://github.com/camsong/blog/issues/3)。

## 其他

- 对于只有render函数的组件，推荐使用函数组件而不是类组件。因为函数组件比类组件性能更优，没有生命周期函数等。

- 对于props，需要使用 propTypes 进行数据类型校验，否则会报错。
