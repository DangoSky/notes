# F&Q

## 工作原理

### 构建的作用

- 构建工具就是将源代码转换成可执行的 JavaScript、CSS、HTML 代码，包括以下内容：
  - 代码转换：将 TypeScript 编译成 JavaScript、将 Less 等编译成 CSS 等。
  - 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。
  - 代码分割：提取多个页面的公共代码，提取首屏不需要执行部分的代码，让其异步加载。
  - 模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。
  - 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。
  - 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。
  - 自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。


### 核心概念

- Entry ：入口，Webpack 执行构建的第一步将从 entry 开始，可抽象成输入。
- Module：模块，配置处理模块的规则。在 Webpack 里一切皆模块，一个模块对应一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。
- Loader：模块转换器，用于将模块的原内容按照需求转换成新内容。
- Resolve：配置寻找模块的规则。
- Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播对应的事件，插件可以监听这些事情的发生，在特定的时机做对应的事情。
- Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。
- Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。


### 流程概述

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，通过执行对象的 run 方法开始执行编译。
3. 确定入口：根据配置中的 entry 找出所有入口文件。
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容及它们之间的依赖关系。
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会。
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中。（在以上过程中，Webpack 会在特定的时间点广播特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。）


### loader 和 plugin

loader 是一个转换器，将 A 文件进行编译成 B 文件，比如将 A.less 转换为 A.css，单纯的文件转换过程。

plugin 针对的是 loader 结束后 webpack 打包的整个过程。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。比如使用 plugin 来根据模板自动生成 HTML 代码并自动引用 CSS 和 JS 文件、将 JS 文件中引用的样式单独抽离成 CSS 文件等。

## 文件打包命名时的 hash 分类

- `[hash]`：基于整个项目内容计算而来，所有文件都共用这个 hash。一旦修改了某一个文件，hash 就会发生改变，会导致其他没有变化的文件的文件名也发生变化，从而使缓存失效。

- `[chunkhash]`：根据不同的入口文件（也就是 entry）进行依赖文件解析并构建对应的代码块（chunk），它是基于每个代码块的内容计算而来。只有代码块中的某个文件内容发生变化了，chunkhash 才会改变，影响范围是这个 chunk 中的文件。

- `[contenthash]`：根据单独的每个文件内容来生成 contenthash，只要文件内容不变，则 contenthash 不变。

## source map

由于打包后的代码是经过压缩的，变量名等信息和源码里的是不一样的，因此不具备良好的可读性。此时如果想要调试源码的话就需要 source map 来映射打包后的代码和源码了。source map 简单来说就是一个 .map 文件，它用于存放源码和编译打包后代码的文件、行号、列号和变量名之间的映射关系。

source map 的几个关键字：

| 关键字 | 含义 | 
| :--: | :--: | 
| eval | 使用 eval 包裹代码 |
| source-map | 生成 .map 文件 |
| cheap | 不包含列信息，也不包括 loader 的 sourcemap |
| module | 包括 loader 的 sourcemap |
| inline | 将 .map 作为 DataURL 嵌入，不单独生成 .map 文件 |

source map 分为几种模式，主要就是将上述的关键字进行组合。比如常使用的 cheap-eval-source-map 表示只包含行信息，并且得到的 source map 由 eval 执行；

[阮一峰：JavaScript Source Map 详解](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)

[打破砂锅问到底：详解Webpack中的sourcemap](https://segmentfault.com/a/1190000008315937)

## tree-shaking

只有 ES6 模块才能使用 tree-shaking，对于 CommonJS 是无法使用 tree-shaking 的。这是因为 tree-shaking 是静态分析的，在编译阶段就去判断每个模块和代码的使用情况，对于没有使用到的部分再做删除操作。而 CommonJS 可以动态 require 一个模块（基于判断来选择是否 require），只有执行后才知道引用的什么模块。

tree-shaking 依赖于 ES6 的模块特性。在 ES6 中，模块导入只能作为顶层的语句出现，也就是说 ES6 模块间的依赖关系是确定的，和运行时的状态无关，所以可以进行可靠的静态分析。

tree-shaking 主要删除了三种类型的代码：

- 代码不会被执行，不可到达。

- 代码执行的结果不会被使用到。

- 代码只会影响到死变量即只读不写。


[Webpack Tree shaking 深入探究](https://juejin.im/post/6844903687412776974)