# F&Q

## 工作原理

### 构建作用

- 构建工具就是将源代码转换成可执行的 JavaScript、CSS、HTML 代码，包括以下内容：
  - 代码转换：将 TypeScript 编译成 JavaScript、将 Less 等编译成 CSS 等。
  - 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。
  - 代码分割：提取多个页面的公共代码，提取首屏不需要执行部分的代码，让其异步加载。
  - 模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。
  - 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。
  - 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。
  - 自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。


### 核心概念

- Entry ：入口，Webpack 执行构建的第一步将从 entry 开始，可抽象成输入。
- Module：模块，配置处理模块的规则。在 Webpack 里一切皆模块，一个模块对应一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。
- Loader：模块转换器，用于将模块的原内容按照需求转换成新内容。
- Resolve：配置寻找模块的规则。
- Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播对应的事件，插件可以监听这些事情的发生，在特定的时机做对应的事情。
- Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。
- Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。


### 流程概述

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，通过执行对象的 run 方法开始执行编译。
3. 确定入口：根据配置中的 entry 找出所有入口文件。
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容及它们之间的依赖关系。
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会。
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中。（在以上过程中，Webpack 会在特定的时间点广播特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。）


### loader 和 plugin

loader 是一个转换器，将 A 文件进行编译成 B 文件，比如将 A.less 转换为 A.css，单纯的文件转换过程。

plugin 针对的是 loader 结束后 webpack 打包的整个过程。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。比如使用 plugin 来根据模板自动生成 HTML 代码并自动引用 CSS 和 JS 文件、将 JS 文件中引用的样式单独抽离成 CSS 文件等。

### source map

将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。

## 文件打包命名时的 hash 分类

- `[hash]`：基于整个项目内容计算而来，所有文件都共用这个 hash。一旦修改了某一个文件，hash 就会发生改变，会导致其他没有变化的文件的文件名也发生变化，从而使缓存失效。

- `[chunkhash]`：根据不同的入口文件（也就是 entry）进行依赖文件解析并构建对应的代码块（chunk），它是基于每个代码块的内容计算而来。只有代码块中的某个文件内容发生变化了，chunkhash 才会改变，影响范围是这个 chunk 中的文件。

- `[contenthash]`：根据单独的每个文件内容来生成 contenthash，只要文件内容不变，则 contenthash 不变。
