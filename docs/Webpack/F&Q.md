# F&Q

## 工作原理

### 构建作用

- 构建工具就是将源代码转换成可执行的 JavaScript、CSS、HTML 代码，包括以下内容：
  - 代码转换：将 TypeScript 编译成 JavaScript、将 Less 等编译成 CSS 等。
  - 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。
  - 代码分割：提取多个页面的公共代码，提取首屏不需要执行部分的代码，让其异步加载。
  - 模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。
  - 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。
  - 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。
  - 自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。


### 核心概念

- Entry ：入口，Webpack 执行构建的第一步将从 entry 开始，可抽象成输入。
- Module：模块，配置处理模块的规则。在 Webpack 里一切皆模块，一个模块对应一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。
- Loader：模块转换器，用于将模块的原内容按照需求转换成新内容。
- Resolve：配置寻找模块的规则。
- Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播对应的事件，插件可以监听这些事情的发生，在特定的时机做对应的事情。
- Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。
- Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。


### 流程概述

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，通过执行对象的 run 方法开始执行编译。
3. 确定入口：根据配置中的 entry 找出所有入口文件。
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容及它们之间的依赖关系。
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会。
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中。（在以上过程中，Webpack 会在特定的时间点广播特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。）




## 文件打包命名时的 hash 分类

- `[hash]`：基于整个项目内容计算而来，所有文件都共用这个 hash。一旦修改了某一个文件，hash 就会发生改变，会导致其他没有变化的文件的文件名也发生变化，从而使缓存失效。

- `[chunkhash]`：根据不同的入口文件进行依赖文件解析并构建对应的代码块（chunk），基于每个代码块的内容计算而来。只有代码块中的文件内容发生变化了，chunkhash 才会改变，影响范围是这个 chunk 中的文件。

- `[contenthash]`：每一个代码块中的 JS 和 CSS 文件都会独立生成一个 hash，当某一个代码块中的 JS 或 CSS 文件被修改时，只有该代码块输出的同种类型文件的 hash 会发生变化。
  - 应用场景：当 JS 文件引用了 CSS 文件，因为两者是在同一个 chunk 下，所以使用 chunkhash 的话，当 JS 文件的内容改变了的话，hash 也变了，会影响到 CSS 文件导致其重新构建。而使用 contenthash 的话，则只要 CSS 文件的内容不变，即使 JS 文件修改了也不会影响到 CSS 文件。


