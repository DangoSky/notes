# Cookie 、 Session 和 Token

## Cookie

> 参考 [HTTP cookies](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)。

- HTTP 是无状态的协议。对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息。可以通过 Cookie 或者 Session 来保存两者通信的状态。Cookie 存储在客户端，在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

- Cookie 的过期时间是相对于客户端时间而言的，设置的时间则是相对于服务器时间而言的，这里有两个问题：

Q：如果服务器在海外，和国内的客户端相差了好几个小时，那么可能海外服务器下发 Cookie 到国内客户端的时候，因为时差 Cookie 就已经失效了。

A：服务器下发 Cookie 的时候会指明时区。

Q：客户端可以修改 Cookie 的有效期，让 Cookie 永久有效。

A：请求时将 Cookie 发送到服务器，服务器会将这个 Cookie 的信息和服务器上对应的这个 Cookie 信息（也可以存在数据库里）做对比，有效的话才会验证通过。

- 可以通过 Domain 和 Path 来限制 Cookie 使用的域名和路径范围。Domain 的默认值为设置该 Cookie 的网页所在域名，Path 默认值为设置该 Cookie 的网页所在的目录。需要注意的是二级域名可以使用一级域名下的 Cookie。但如果是跨域请求，即使 Domain 和 Path 都满足，Cookie 也不会被添加到请求中。

- Secure 属性：设置为 true 的话表示该 Cookie 只能在 https 中使用。需要注意的是通过 JavaScript 修改 Secure 属性时，必须保证网页是 https 协议的，在 http 协议的网页中是无法设置 Secure 类型的 Cookie的。

- HttpOnly 属性：设置为 true 的话表示该 Cookie 只能在服务端访问，不能被 JavaScript 访问到。

- Expires/Max-age 属性：表示 Cookie 的有效时间。
    - Expires 是一个时间点表示 Cookie 失效的时刻，必须是 GMT 格式的时间，可以通过 `new Date().toGMTString()` 装换。默认值为 Session，表示有效期是到浏览器关闭的时候。
    - Max-age 的值是一个以秒为单位的时间段，表示从现在开始多少秒后 Cookie 失效。Max-age 有三种可能值：负数、0、正数。负数表示会话级 Cookie（默认值 -1）；0 表示删除 Cookie；正数表示有效期为创建时刻加上该 Max-age 值。

- 设置 Cookie：
    - 服务端通过响应头中的 `Set-cookie` 字段设置。
    - 客户端设置：
        - `document.cookie = "${name}=${value}; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=${domain}"`
    - 注意如果在客户端修改 Cookie，新旧 Cookie 的 Domain 和 Path 属性需要保持一致，否则就成了设置新的 Cookie 了。
    - 最好对 Cookie 的键值使用 escape 和 unescape 进行编码解码，防止中间包含逗号、分号、空格而被当做特殊字符。


## Session 

- Session 也是记录服务器和客户端会话状态的机制。Session 是基于 Cookie 实现的，Session 存储在服务器端，而链接对应的 SessionId 存储在客户端中比如 Cookie 里。

- Session 认证流程：用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session。请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器。浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

- Session 的扩展性不是很好。对于负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享 seesion。这个问题也可以将 Session 存在一个服务器中来解决，但就不能完全达到负载均衡的效果了。

- Cookie 和 Session 的区别

  - 安全性：Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的（Session 只在客户端存储一个 SessionID，而 Cookie 把所有数据都存在了客户端）。
  - 存取值的类型不同：Cookie 只支持存储字符串数据，Session 可以存任意数据类型。
  - 存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是太多的 Session 会占用过多的服务器资源。
  - 有效期不同：Cookie 的有效期可以自行设置，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。

- 移动端对 Cookie 的支持不是很好，而 SessionId 需要存储在 Cookie 中（但也可以直接把 SessionId 拼接在 url 后面），所以移动端常用的是 Token。


## Token

- Token 是访问资源接口时所需要的资源凭证，由服务端采用一定的算法生成发给客户端。

- Token 的组成： 
  - uid：用户唯一的身份标识。
  - time：当前时间的时间戳。
  - sign：签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串。
  - 还可以把其他的参数也放进 Token，避免多次查库。

- 特点：

  - 无状态。服务器不需要存储相关信息，只需要验证 Token 即可。
  - 服务端无状态化、可扩展性好。
  - 支持移动端设备。
  - 安全。Token 有时效性，并且可以撤回使 Token 失效。
  - 支持跨程序调用。比如可以通过授权给出 Token，让第三方应用调用自己的 api。

- 使用过程：客户端先通过登录等方式在服务器验证后获取 Token，存储在客户端的 Cookie 或 storage 里。以后向服务器发送请求时都带上 Token（携放在 HTTP 请求头的 Authorization 字段里，跨域的时候就放在 POST 请求的数据体里面），只有 Token 正确时服务器才对请求作出应答。

- 基于 Token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 Token 数据。用解析 Token 的计算时间换取 Session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。并且 Token 完全由应用管理，所以它可以避开同源策略。


## JWT

#### 组成

- Header 头部：包括 Token 的类型比如是 JWT、使用的签名算法。
- Payload 负载：包括实际传送的数据，比如签发人、签发时间、有效时间、受众等。也可以在这里定义额外的字段。
- Signature 签名：服务端使用只有服务端才知道的秘钥和 Header 里指明的签名说法，对前面两个部分进行加密，防止数据篡改。
- （上面三部分要使用 Base64URL 算法转成字符串，并且分别使用 . 隔开）。

#### 一般的用户认证流程

- 用户向服务器发送用户名和密码。
- 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。
- 服务器向用户返回一个 session_id，写入用户的 Cookie。
- 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。
- 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。

问题在于扩展性不好，如果是服务器集群，就要求 session 数据共享，每台服务器都能够读取 session（比如 A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录）。

解决方案：

- session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

- 服务器不保存 session 数据，所有数据都保存在客户端，每次请求都发回服务器。JWT（Json Web Tokens） 就是这种方案的一个代表。

#### JWT 原理

JWT 的原理是，服务器认证以后，生成一个 JSON 对象（记录用户身份和有效期）发回给用户。以后用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。


#### 使用方式

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。此后客户端每次与服务器通信，都要带上这个 JWT。可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 Authorization 字段里面`Authorization: Bearer <token>`。另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

#### JWT 的几个特点

- JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
- JWT 不加密的情况下，不能将秘密数据写入 JWT。
- JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
- JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
- JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
- 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

> [更多参考](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)



## SSO 单点登录

- CAS 中央认证服务，所有子系统的登录访问都由中央认证系统统一认证。

- **登录原理**：

  - 用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 SSO 认证中心，并将自己的地址作为参数。
  - SSO 认证中心发现用户未登录，将用户引导至登录页面。
  - 用户输入用户名密码提交登录申请。
  - SSO 认证中心校验用户信息，创建用户与 SSO 认证中心之间的会话，称为全局会话，同时创建授权令牌。
  - SSO 认证中心带着令牌跳转会最初的请求地址（系统 1）。
  - 系统 1 拿到令牌，去 SSO 认证中心校验令牌是否有效。
  - SSO 认证中心校验令牌，返回有效，注册系统 1。
  - 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源。
  - 用户访问系统 2 的受保护资源。
  - 系统 2 发现用户未登录，跳转至 SSO 认证中心，并将自己的地址作为参数。
  - SSO 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌。
  - 系统 2 拿到令牌，去 SSO 认证中心校验令牌是否有效。
  - SSO 认证中心校验令牌，返回有效，注册系统 2。
  - 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源。

![](./images/5.png)

- 全局会话与局部会话：

  - 全局会话：用户与 SSO 认证中心建立的会话。
  - 局部会话：用户与各个子系统建立的会话。局部会话建立之后，用户访问子系统受保护资源将不再通过 SSO 认证中心。
  - 两者的约束关系：
    - 局部会话存在，全局会话一定存在。
    - 全局会话存在，局部会话不一定存在。
    - 全局会话销毁，局部会话必须销毁。

- **注销原理**：
  - 用户向系统 1 发起注销请求。
  - 系统 1 根据用户与系统 1 建立的会话 id 拿到令牌，向 SSO 认证中心发起注销请求。
  - SSO 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址。
  - SSO 认证中心向所有注册系统发起注销请求。
  - 各注册系统接收 SSO 认证中心的注销请求，销毁局部会话。
  - SSO 认证中心引导用户至登录页面。

![](./images/6.png)

36 6 3
1：6次 淘汰18  剩下18
2：3次 