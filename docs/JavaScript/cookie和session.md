# Cookie 、 Session 和 Token

## Cookie

- HTTP 是无状态的协议。对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息。可以通过 Cookie 或者 Session 来保存两者通信的状态。

- 存储在客户端。在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

- 可以通过 domain 和 path 来限制 Cookie 使用的域名和路径范围。（二级域名可以使用一级域名下的 Cookie）


## Session 

- Session 也是记录服务器和客户端会话状态的机制。Session 是基于 Cookie 实现的，Session 存储在服务器端，而链接对应的 SessionId 存储在客户端中比如 Cookie 里。

- Session 认证流程：用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session。请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器。浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

- Session 的扩展性不是很好。对于负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享 seesion。这个问题也可以将 Session 存在一个服务器中来解决，但就不能完全达到负载均衡的效果了。

- Cookie 和 Session 的区别

  - 安全性：Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的（Session 只在客户端存储一个 SessionID，而 Cookie 把所有数据都存在了客户端）。
  - 存取值的类型不同：Cookie 只支持存储字符串数据，Session 可以存任意数据类型。
  - 存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是太多的 Session 会占用过多的服务器资源。
  - 有效期不同：Cookie 的有效期可以自行设置，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。

- 移动端对 Cookie 的支持不是很好，而 SessionId 需要存储在 Cookie 中（但也可以直接把 SessionId 拼接在 url 后面），所以移动端常用的是 Token。


## Token

- Token 是访问资源接口时所需要的资源凭证，由服务端采用一定的算法生成发给客户端。

- Token 的组成： 
  - uid：用户唯一的身份标识。
  - time：当前时间的时间戳。
  - sign：签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串。
  - 还可以把其他的参数也放进 Token，避免多次查库。

- 特点：

  - 无状态。服务器不需要存储相关信息，只需要验证 Token 即可。
  - 服务端无状态化、可扩展性好。
  - 支持移动端设备。
  - 安全。Token 有时效性，并且可以撤回使 Token 失效。
  - 支持跨程序调用。比如可以通过授权给出 Token，让第三方应用调用自己的 api。

- 使用过程：客户端先通过登录等方式在服务器验证后获取 Token，存储在客户端的 Cookie 或 storage 里。以后向服务器发送请求时都带上 Token（携放在 HTTP 请求头的 Authorization 字段里，跨域的时候就放在 POST 请求的数据体里面），只有 Token 正确时服务器才对请求作出应答。

- 基于 Token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 Token 数据。用解析 Token 的计算时间换取 Session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。并且 Token 完全由应用管理，所以它可以避开同源策略。


## JWT

- 组成：

  - Header 头部：包括 Token 的类型比如是 JWT、使用的签名算法。
  - Payload 负载：包括实际传送的数据，比如签发人、签发时间、有效时间、受众等。也可以在这里定义额外的字段。
  - Signature 签名：服务端使用只有服务端才知道的秘钥和 Header 里指明的签名说法，对前面两个部分进行加密，防止数据篡改。
  - （上面三部分要使用 Base64URL 算法转成字符串，并且分别使用 . 隔开）。

- JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。

- JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT 可以降低服务器查询数据库的次数。


## SSO 单点登录

- CAS 中央认证服务，所有子系统的登录访问都由中央认证系统统一认证。

- **登录原理**：

  - 用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 SSO 认证中心，并将自己的地址作为参数。
  - SSO 认证中心发现用户未登录，将用户引导至登录页面。
  - 用户输入用户名密码提交登录申请。
  - SSO 认证中心校验用户信息，创建用户与 SSO 认证中心之间的会话，称为全局会话，同时创建授权令牌。
  - SSO 认证中心带着令牌跳转会最初的请求地址（系统 1）。
  - 系统 1 拿到令牌，去 SSO 认证中心校验令牌是否有效。
  - SSO 认证中心校验令牌，返回有效，注册系统 1。
  - 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源。
  - 用户访问系统 2 的受保护资源。
  - 系统 2 发现用户未登录，跳转至 SSO 认证中心，并将自己的地址作为参数。
  - SSO 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌。
  - 系统 2 拿到令牌，去 SSO 认证中心校验令牌是否有效。
  - SSO 认证中心校验令牌，返回有效，注册系统 2。
  - 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源。

![](./images/5.png)

- 全局会话与局部会话：

  - 全局会话：用户与 SSO 认证中心建立的会话。
  - 局部会话：用户与各个子系统建立的会话。局部会话建立之后，用户访问子系统受保护资源将不再通过 SSO 认证中心。
  - 两者的约束关系：
    - 局部会话存在，全局会话一定存在。
    - 全局会话存在，局部会话不一定存在。
    - 全局会话销毁，局部会话必须销毁。

- **注销原理**：
  - 用户向系统 1 发起注销请求。
  - 系统 1 根据用户与系统 1 建立的会话 id 拿到令牌，向 SSO 认证中心发起注销请求。
  - SSO 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址。
  - SSO 认证中心向所有注册系统发起注销请求。
  - 各注册系统接收 SSO 认证中心的注销请求，销毁局部会话。
  - SSO 认证中心引导用户至登录页面。

![](./images/6.png)
