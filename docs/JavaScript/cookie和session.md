# cookie 和 session

## cookie

- HTTP 是无状态的协议。对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息。可以通过 cookie 或者 session 来保存两者通信的状态。

- 存储在客户端。在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

- 可以通过 domain 和 path 来限制 cookie 使用的域名和路径范围。（一级域名和二级域名之间是允许共享使用的）


## session 

- session 是另一种记录服务器和客户端会话状态的机制。

- session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中。

- session 认证流程：用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session。请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器。浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

- 对于负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享 seesion。这个问题也可以将 session 存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。

- Cookie 和 Session 的区别

  - 安全性：Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的（session 只在客户端存储一个 sessionID，而 cookie 把所有数据都存在了客户端）。
  - 存取值的类型不同：Cookie 只支持存储字符串数据，Session 可以存任意数据类型。
  - 有效期不同：Cookie 的有效期可以自行设置，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
  - 存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是太多的 session 会占用过多的服务器资源。

- 移动端对 cookie 的支持不是很好，而 sessionId 需要存储在 cookie 中（但也可以直接把 sessionId 拼接在 url 后面），所以移动端常用的是 token。


## token

- token 是访问资源接口时所需要的资源凭证。

- 简单 token 的组成： 
  - uid：用户唯一的身份标识。
  - time：当前时间的时间戳。
  - sign：签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串。

- 特点：

  - 无状态。服务器不需要存储相关信息，只需要验证 token 即可。
  - 服务端无状态化、可扩展性好。
  - 支持移动端设备。
  - 安全。
  - 支持跨程序调用。

- 使用过程：客户端先通过登录等方式在服务器验证后获取 token，存储在客户端的 cookie 或 storage 里。以后向服务器发送请求时都带上 token（携放在 HTTP 的 Header 里），只有 token 正确时服务器才对请求作出应答。

- 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。并且 token 完全由应用管理，所以它可以避开同源策略。


## SSO 单点登录

- CAS 中央认证服务，所有子系统的登录访问都由中央认证系统统一认证。

- **登录原理**：

  - 用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数。
  - sso 认证中心发现用户未登录，将用户引导至登录页面。
  - 用户输入用户名密码提交登录申请。
  - sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌。
  - sso 认证中心带着令牌跳转会最初的请求地址（系统 1）。
  - 系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效。
  - sso 认证中心校验令牌，返回有效，注册系统 1。
  - 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源。
  - 用户访问系统 2 的受保护资源。
  - 系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数。
  - sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌。
  - 系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效。
  - sso 认证中心校验令牌，返回有效，注册系统 2。
  - 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源。

![](./images/5.png)

- 全局会话与局部会话：

  - 全局会话：用户与 sso 认证中心建立的会话。
  - 局部会话：用户与各个子系统建立的会话。局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心。
  - 两者的约束关系：
    - 局部会话存在，全局会话一定存在。
    - 全局会话存在，局部会话不一定存在。
    - 全局会话销毁，局部会话必须销毁。

- **注销原理**：
  - 用户向系统 1 发起注销请求。
  - 系统 1 根据用户与系统 1 建立的会话 id 拿到令牌，向 sso 认证中心发起注销请求。
  - sso 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址。
  - sso 认证中心向所有注册系统发起注销请求。
  - 各注册系统接收 sso 认证中心的注销请求，销毁局部会话。
  - sso 认证中心引导用户至登录页面。

![](./images/6.png)
