# Cookie 、 Session 和 Token

## Cookie

> [HTTP cookies](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)
>
> [预测最近面试会考 Cookie 的 SameSite 属性](https://juejin.im/post/5e718ecc6fb9a07cda098c2d)

HTTP 是无状态的协议。对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息。可以通过 Cookie 或者 Session 来保存两者通信的状态。Cookie 存储在客户端，在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

#### Cookie 的属性

- Domain 和 Path：可以用来限制 Cookie 使用的域名和路径范围。Domain 的默认值为设置该 Cookie 的网页所在域名，Path 默认值为设置该 Cookie 的网页所在的目录。需要注意的是二级域名可以使用一级域名下的 Cookie。但如果是跨域请求，即使 Domain 和 Path 都满足，Cookie 也不会被添加到请求中。

- Secure：设置为 true 的话表示该 Cookie 只能在 https 中使用。需要注意的是通过 JavaScript 修改 Secure 属性时，必须保证网页是 https 协议的，在 http 协议的网页中是无法设置 Secure 类型的 Cookie的。

- HttpOnly：设置为 true 的话表示该 Cookie 只能在服务端访问，不能被 JavaScript 访问到。

- Expires/Max-age 属性：表示 Cookie 的有效时间（如果 Expires 和 Max-age 都存在的话，Max-age 优先级更高）。
  - Expires 是一个时间点表示 Cookie 失效的时刻，必须是 GMT 格式的时间，可以通过 `new Date().toGMTString()` 装换。默认值为 Session，表示有效期是到浏览器关闭的时候。
  - Max-age 的值是一个以秒为单位的时间段，表示从现在开始多少秒后 Cookie 失效。Max-age 有三种可能值：负数、0、正数。负数表示会话级 Cookie（默认值是 -1）；0 表示立即删除 Cookie；正数表示有效期为创建时刻加上该 Max-age 值。

- SameSite：控制在跨站请求时是否要发送 Cookie，可以用来防止 CSRF 攻击。之前默认值是 None，Chrome80 后默认是 Lax。它可以设置以下三个值：
  - Strict：跨站点时任何情况下都不会发送 Cookie。只有当前网页的 URL 与请求目标一致，才会带上 Cookie。比如访问 google.com，只有在 google.com 域名下的的请求才会携带上 Cookie。
  - Lax：只有导航到目标网址的 Get 请求才允许发送 Cookie，其他的一律禁止。比如 a 链接、link 加载静态资源、GET 表单请求等。而 POST 请求、AJAX 请求、img 链接、iframe 链接等则禁止带上 Cookie。
  - None：关闭 SameSite 属性，但同时要设置 Secure 属性，否则无效。
  - （Samesite Cookie 目前有一个致命的缺陷：不支持子域。例如在 topic.a.com 下的 Cookie，并不能使用 a.com 下的 Samesite Cookie。


#### Cookie 有效时间 FAQ

Cookie 的过期时间是相对于客户端时间而言的，设置的时间则是相对于服务器时间而言的，这里有两个问题：

Q：如果服务器在海外，和国内的客户端相差了好几个小时，那么可能海外服务器下发 Cookie 到国内客户端的时候，因为时差 Cookie 就已经失效了。

A：服务器下发 Cookie 的时候会指明时区。

Q：客户端可以修改 Cookie 的有效期，让 Cookie 永久有效。

A：请求时将 Cookie 发送到服务器，服务器会将这个 Cookie 的信息和服务器上对应的这个 Cookie 信息（也可以存在数据库里）做对比，有效的话才会验证通过。

#### 设置 Cookie

- 服务端通过响应头中的 `Set-cookie` 字段设置。
- 客户端设置：
  - `document.cookie = "${name}=${value}; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=${domain}"`
- 注意如果在客户端修改 Cookie，新旧 Cookie 的 Domain 和 Path 属性需要保持一致，否则就成了设置新的 Cookie 了。
- 最好对 Cookie 的键值使用 escape 和 unescape 进行编码解码，防止中间包含逗号、分号、空格而被当做特殊字符。


## Session 

Session 也是记录服务器和客户端会话状态的工具。

#### Session 认证流程

1. 用户第一次请求服务器的时候，服务器创建对应的 Session 来保存用户信息，并把 Session 的唯一标识信息 SessionID 返回给客户端。
2. 客户端接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。
3. 当客户端第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在则自动将 Cookie 信息也发送给服务端。
4. 收到请求中的 SessionID 后，服务端会根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

#### Session 的缺点

- 扩展性不好。如果是服务器集群的话，就要求 Session 数据共享，使得每台服务器都能够读取到 Session（比如 A 网站和 B 网站是同一家公司的关联服务，现在要求用户只要在其中一个网站登录，再访问另一个网站就会自动登录）。然而 Session 信息难以同步，因为服务器之间并不共享 Seesion。
  - 每台服务器上的 Session 发生改变后，就将其广播给其他的服务器。
  - 将 Session 集中存储在某台服务器上，验证时都将请求定向到该服务器上。
  - 将 Session 存储到数据库中，保证 Session 的持久化。

- Session 存储在服务端，如果存储的数量太多，可能会对服务器存储造成一定的压力。

- SessionId 存储在 Cookie 中，而移动端对 Cookie 支持不是很好（部分手机浏览器可能会禁用掉 Cookie），所以移动端常用的是 Token，当然也可以选择把 SessionId 放在 url 后面。

#### Cookie 和 Session 的区别

- 安全性：Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的（Session 只在客户端存储一个 SessionID，而 Cookie 把所有数据都存在了客户端）。
- 存取值的类型不同：Cookie 只支持存储字符串数据，Session 可以存任意数据类型。
- 存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是太多的 Session 会占用过多的服务器资源。
- 有效期不同：Cookie 的有效期可以自行设置，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。


## Token

#### 解决的问题

Session 扩展性不好，服务器集群之间难以共享。虽然可以将 Session 存在一个服务器中，其他服务器都向它请求 Session 数据，但这样容易造成单点失败，并且也不能很好达到负载均衡的效果。

而 Token 选择将信息加密后存储在客户端，客户端下一次请求时带上这个 Token 给服务端验证即可。解决了 Session 扩展性不好的的问题，也减轻了服务端存储 Session 的压力。

#### Token 的组成

- uid：用户唯一的身份标识。
- time：当前时间的时间戳。
- sign：签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串。
- 还可以把其他的参数也放进 Token，避免多次查库。

#### Token 的特点

- 无状态。服务器不需要存储相关信息，只需要验证 Token 即可。
- 服务端无状态化、可扩展性好。
- 支持移动端设备。
- 安全。Token 有时效性，并且可以撤回使 Token 失效。
- 支持跨程序调用。比如可以通过授权给出 Token，让第三方应用调用自己的 api。
- 由应用管理，所以它可以避开同源策略。

#### Token 的认证过程

1. 客户端先通过账号密码等方式登录。
2. 验证通过后，服务端把用户信息通过加密算法和一个只有服务端知道的密钥，来生成一个字符串也就是 Token，并返回给客户端。
3. 客户端收到 Token 后将其存储在 Cookie 或 storage 里。
4. 客户端以后向服务器发送请求时都带上 Token（携放在 HTTP 请求头的 Authorization 字段里。或者放在 Cookie 里，当跨域的时候就放在 POST 请求的数据体里面）。
5. 服务端用相同的算法和密钥生成一个新的 Token，去比较验证这两个 Token，验证通过才执行后面的操作。


#### Token 和 Ssession 的异同

- Session 是一种记录服务器和客户端会话状态的机制，服务端是有状态的，可以记录会话信息。而 Token 是令牌，访问 API 时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。

- 作为身份认证，Token 安全性比 Session 好。 Session 的验证是基于 SessionID 的，只要请求方有了 SessionID 就认为它有了该用户的所有权利，即使 SessionID 被盗取服务端也不会进一步验证请求者身份。而 Token 不仅有签名而且验证是基于 Token 里的用户信息的，即使被盗取了中间人也无法获取相应的用户权限。

## JWT

#### JWT 组成

- Header 头部：包括 Token 的类型比如是 JWT、使用的签名算法。
- Payload 负载：包括实际传送的数据，比如签发人、签发时间、有效时间、接收者等。也可以在这里定义额外的字段。
- Signature 签名：服务端使用只有服务端才知道的秘钥和 Header 里指明的签名算法，对前面两个部分进行加密，防止数据篡改。
- （上面三部分要使用 Base64URL 算法转成字符串，并且分别使用  `.` 隔开）。

#### JWT 原理

服务器认证以后，生成一个 JSON 对象（记录用户身份和有效期）返回给用户。以后用户与服务端通信的时候，都要发送这个 JSON 对象。服务器完全只靠这个对象认定用户身份。**为了防止用户篡改数据，服务器在生成这个对象的时候会加上签名**。

#### JWT 的几个特点

- JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次（JWT 不加密的情况下，不能将秘密数据写入 JWT）。
- JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
- JWT 的最大缺点是，由于服务器不保存 Session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
- JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
- 为了减少盗用，JWT 不应该使用 HTTP 协议明文传输，要使用 HTTPS 协议传输。

> [JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

> [使用NodeJS实现JWT原理](https://juejin.im/post/6873700061000237069)

#### JWT 的缺点

- 由于服务器不需要存储 Token 信息的，所以中途无法废弃某个 Token 或者更改 Token 的权限。

#### JWT 和 Token 的异同

- 相同点
  - 都是访问资源的令牌。
  - 都可以记录用户的信息。
  - 都是使服务端无状态化。
  - 都是只有验证成功后，客户端才能访问服务端上受保护的资源。

- 不同点
  - Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息（Token 可以存到 redis 中，服务端验证的时候需要查 redis 去比对 Token，而 JWT 不需要存到 redis），然后验证 Token 是否有效。
  - JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。


## SSO 单点登录

- CAS 中央认证服务，所有子系统的登录访问都由中央认证系统统一认证，认证成功后再颁发 token 给各个子系统，通过 token 来建立和子系统的会话。

- **登录原理**：

  - 用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 SSO 认证中心，并将自己的地址作为参数。
  - SSO 认证中心发现用户未登录，将用户引导至登录页面。
  - 用户输入用户名密码提交登录申请。
  - SSO 认证中心校验用户信息，创建用户与 SSO 认证中心之间的会话，称为全局会话，同时创建授权令牌。
  - SSO 认证中心带着令牌跳转回最初的请求地址（系统 1）。
  - 系统 1 拿到令牌，去 SSO 认证中心校验令牌是否有效。
  - SSO 认证中心校验令牌，返回有效，注册系统 1。
  - 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源。
  - 用户访问系统 2 的受保护资源。
  - 系统 2 发现用户未登录，跳转至 SSO 认证中心，并将自己的地址作为参数。
  - SSO 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌。
  - 系统 2 拿到令牌，去 SSO 认证中心校验令牌是否有效。
  - SSO 认证中心校验令牌，返回有效，注册系统 2。
  - 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源。

![](./images/5.png)

- 全局会话与局部会话：
  - 全局会话：用户与 SSO 认证中心建立的会话。
  - 局部会话：用户与各个子系统建立的会话。局部会话建立之后，用户访问子系统受保护资源将不再通过 SSO 认证中心。
  - 两者的约束关系：
    - 局部会话存在，全局会话一定存在。
    - 全局会话存在，局部会话不一定存在。
    - 全局会话销毁，局部会话必须销毁。

- **注销原理**：
  - 用户向系统 1 发起注销请求。
  - 系统 1 根据用户与系统 1 建立的会话 id 拿到令牌，向 SSO 认证中心发起注销请求。
  - SSO 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址。
  - SSO 认证中心向所有注册系统发起注销请求。
  - 各注册系统接收 SSO 认证中心的注销请求，销毁局部会话。
  - SSO 认证中心引导用户至登录页面。

![](./images/6.png)
