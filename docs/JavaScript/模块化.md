# 模块化

## CommonJS

### 加载机制

- CommonJS 规范加载模块是同步的。Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，加载起来比较快，所以使用 CommonJS。

- 模块的循环加载：如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。

- CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说一旦输出一个值，模块内部的变化就影响不到这个值。


### module 对象

每个模块内部，都有一个module对象，代表当前模块。它有以下属性。

- module.id: 模块的识别符，通常是带有绝对路径的模块文件名。
- module.filename: 模块的文件名，带有绝对路径。
- module.loaded: 返回一个布尔值，表示模块是否已经完成加载。
- module.parent: 返回一个对象，表示调用该模块的模块。
- module.children: 返回一个数组，表示该模块要用到的其他模块。
- module.exports: 表示模块对外输出的值。

### require 缓存

对于同一个模块的导出对象只会初始化一次，而不会因为两次 require 就初始化两次，导出的对象会被缓存起来。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。

### exports 和 module.exports 的区别

exports 对象用来导出当前模块的公共方法或属性，别的模块通过 require 函数使用当前模块时得到的就是当前模块的 exports 对象。module.exports 用来导出一个默认对象，没有指定对象名，常见于修改模块的原始导出对象。

- exports 是指向的 module.exports 的引用。等同于 `var exports = module.exports`。
- module.exports 初始值为一个空对象 {}，所以 exports 初始值也是 {}。
- require() 返回的是 module.exports 而不是 exports。
- exports = 相当于给 exports 对象重新赋值，调用模块就不能再访问 exports 对象及其属性。

### require加载第三方包的规则

1. require('第三方包名')优先在加载该包的模块的同级目录node_modules中查找第三方包。

2. 找到该第三方包中的package.json文件，并且找到里面的main属性对应的入口模块，该入口模块即为加载的第三方模块。

3. 如果在要加载的第三方包中没有找到package.json文件或者是package.json文件中没有main属性，则默认加载第三方包中的index.js文件。

4. 如果在加载第三方模块的文件的同级目录没有找到node_modules文件夹，或者以上所有情况都没有找到，则会向上一级父级目录下查找node_modules文件夹，查找规则如上一致。

5. 如果一直找到该模块的磁盘根路径都没有找到，则会报错：can not find module xxx。


### require的内部处理流程

require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。

```js
Module._load = function(request, parent, isMain) {
  // 1. 检查 Module._cache，是否缓存之中有指定模块
  // 2. 如果缓存之中没有，就创建一个新的Module实例
  // 3. 将它保存到缓存
  // 4. 使用 module.load() 加载指定的模块文件，
  //    读取文件内容之后，使用 module.compile() 执行文件代码
  // 5. 如果加载/解析过程报错，就从缓存删除该模块
  // 6. 返回该模块的 module.exports
};
```

上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。

```js
Module.prototype._compile = function(content, filename) {
  // 1. 生成一个require函数，指向module.require
  // 2. 加载其他辅助方法到require
  // 3. 将文件内容放到一个函数之中，该函数可调用 require
  // 4. 执行该函数
};
```

上面的第1步和第2步，require函数及其辅助方法主要如下。

- require(): 加载外部模块
- require.resolve()：将模块名解析到一个绝对路径
- require.main：指向主模块
- require.cache：指向所有缓存的模块
- require.extensions：根据文件的后缀名，调用不同的执行函数

一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。

```js
(function (exports, require, module, __filename, __dirname) {
  // YOUR CODE INJECTED HERE!
});
```

Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。

## AMD

- AMD 规范则是非同步加载模块，允许指定回调函数。浏览器环境要从服务器端加载模块，就得使用 AMD。

## ES6

ES6 的 import 导入其实是对变量的引用，模块内变量改变了引用的地方也会改变。但 `export default x`， 导出的是此时到该变量的绑定，而不是标识符 x，所以之后 x 改变了，引用x的地方也不会随之改变。`export { x as default }` 则还是对变量的引用。
