# 其他

## 数组 api 整理

#### 改变原数组的方法

- splice

如果只有一个参数，等同于将原数组在指定位置拆分成两个数组，并返回被删除的元素。`[1,2,3,4].splice(2)  // [3, 4]`

- sort

若比较函数返回值 <0，a 在前。若比较函数返回值> 0，b 在前。会 **返回一个到数组本身的引用**，后续对其中一个数组的操作会修改到两个。

- pop

- shift

删除后返回这一个元素，上同

- push

- unshift

添加一个或多个元素，并返回数组长度，上同

- reverse 会**返回一个到数组本身的引用**。

- copyWithin(target, start, end)

将 start 到 end 位置之间的字符复制到 target 位上，读了几个元素就从开始被替换的地方替换几个元素。**会返回一个到数组本身的引用**。

- fill(val, start, end)

用 val 填充 start 到 end 之间的字符，会代替原先位置上的字符。如果要填充的字符是引用类型，则 **被填充的几个元素都是引用同一个地址**，即对其中一个的操作会修改到其他几个。

```js
var arr = Array(3).fill({})    // [{}, {}, {}];
arr[0].hi = "hi";              // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]

let arr = new Array(3).fill([]);   // [[], [], []]
arr[0].push(5);                    // [[5], [5], [5]]
```


#### 不改变原数组的方法

- slice

`Array.prototype.slice.call({0: 'a', 1: 'b', length: 2})   // ['a', 'b']`

- concat

- flat(deep）

返回一个新数组，不改变原数组。会移除数组中的空项。 `[1,2,,,].flat() // [1, 2]`

- flatMap()

对每个成员执行一个函数（相当于 map()），然后对返回值组成的数组执行 flat() 方法。该方法同样返回一个新数组，不改变原数组。

```js
[2, 3, 4].flatMap((x) => [x, x * 2])

// 相当于 [[2, 4], [3, 6], [4, 8]].flat()  -> [2, 4, 3, 6, 4, 8]
// flatMap() 只能展开一层数组。
```


#### forEach

- 特性
  - 无法中途退出循环，只能用 return 退出本次回调，进行下一次回调。
  - 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数 (对于 undefined 和 null 则不会跳过)
  - 遍历次数在第一次循环前就会确定，再添加到数组中的元素不会被遍历。

- 对于空数组，some 方法返回 false，every 方法返回 true，回调函数都不会执行。

#### 数组空位

数组的空位指，数组的某一个位置没有任何值。空位不是 undefined，一个位置的值等于 undefined，依然是有值的。空位是没有任何值，in 运算符可以说明这一点 (in 查找不到空位)。

```js
0 in [undefined, undefined, undefined]     // true
0 in Array(3) // false， 相当于 [, , ,]
```

## JS 数据

#### 原始数据

- 原始类型的值可以自动当作包装对象调用，即调用包装对象的属性和方法。这时 JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。比如，字符串可以调用 length 属性。**自动转换生成的包装对象是只读的**，无法修改。所以，字符串无法添加新属性。这意味着下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象 String.prototype 上定义。

-  基本数据类型的值不可变，动态修改后原始值也是不变的，如修改字符串某一位上的字符并不会改变原字符串，而是返回一个新的基本类型。

- 进制转换：
  - 十进制转为其他进制：`(17).toString(16)`。把十进制的 17 转为十六进制。
  - 其他进制转为十进制：`parseInt(11, 16)`。把 11 当做十六进制看待，解析成十进制。

#### 操作符的优先级

![](./images/4.png)

#### let

- 在程序或者函数的顶层，let 和 const 并不会像 var 一样在全局对象上创造一个属性。

```js
var x = 'global';
let y = 'global';
console.log(this.x); // "global"
console.log(this.y); // undefined

let val = 10;
let fn = function() {
  return this.val;  // undefined
}
console.log(fn());
```

- let 的变量提升和暂时性死区。

```js
var temp = 123;
if (true) {
  console.log(temp);
  let temp;
}

// 如果 let 有变量提升的话，temp 应该打印出 undefined，但并没有，说明没有变量提升。而按 var 的规则，此时 temp 可以向上层作用域获取到 22，但也没有，说明 let 声明的变量存在暂时性死区。
```

## DOM 操作

#### 节点操作

- 在 targetElement 后面插入一个节点，targetElement 和新节点是兄弟节点关系。

```js
function insertAfter(newElement, targetElement){
 var parent = targetElement.parentNode;
  // 如果目标节点已经是最后一个元素，那么直接添加即可
  if(targetElement === parent.lastChild){
    parent.appendChild(newElement);
  } else {
    //否则，在当前节点的下一个节点之前添加
    parent.insertBefore(newElement,targetElement.nextSibling);
  }
}
```


#### `MutationObserver` 观测 DOM 节点变化

> 参考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)。

使用 `new MutationObserver()` 创建一个 `MutationObserver` 对象，并传入一个回调函数可在 DOM 节点发生相应变化时触发。实例化出来的 `MutationObserver` 对象有三个方法：`disconnect`、`observe`、`takeRecords`。

使用 `mutationObserver.observe(target[, options])` 可以监测某一个 DOM 节点，常用的配置选项有：`childList` 表示是否监测 DOM 节点的子孙节点，默认为 false；`attributes` 表示是否监测 DOM 节点的属性变换，默认也为 false。`subtree` 表示是否将监视范围扩展至目标节点整个节点树中的所有节点，默认也为 false。

```js
var targetNode = document.getElementById('some-id');
var config = { attributes: true, childList: true, subtree: true };

// Callback function to execute when mutations are observed
var callback = function(mutationsList) {
  for(var mutation of mutationsList) {
    if (mutation.type == 'childList') {
      console.log('A child node has been added or removed.');
    }
    else if (mutation.type == 'attributes') {
      console.log('The ' + mutation.attributeName + ' attribute was modified.');
    }
  }
};

var observer = new MutationObserver(callback);
observer.observe(targetNode, config);
observer.disconnect();
```

## Reflect

- 作用
  - 规范化方法分类。将 Object 对象的一些明显属于语言内部的方法（比如 `Object.defineProperty`），放到 Reflect 对象上。
  - 修改某些 Object 方法的返回结果，让其变得更合理。比如 `Object.defineProperty(obj, name, desc)` 在无法定义属性时，会抛出一个错误，而 `Reflect.defineProperty(obj, name, desc)` 则会返回 false。
  - 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 `name in obj` 和 `delete obj[name]`，而 `Reflect.has(obj, name)` 和 `Reflect.deleteProperty(obj, name)` 让它们变成了函数行为。
  - Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法。

## 离线缓存 manifest

- 介绍：在 manifest 文件中定义那些需要缓存的文件，支持 manifest 的浏览器将按照 manifest 文件的规则将文件保存在本地，从而在没有网络链接的情况下，也能访问页面。我们第一次正确配置 app cache 后，当再次访问该应用时，浏览器会首先检查 manifest 文件是否有变动，如果有变动就会把相应的变动更新下来，同时改变浏览器里面的app cache；如果没有变动，就会直接把 app cache 的资源返回。

- 特点：
  - 离线浏览：用户可以在离线状态下浏览网站内容。
  - 更快的速度：因为数据被存储在本地，所以速度会更快.
  - 减轻服务器的负载：浏览器只会下载在服务器上发生改变的资源。
  - 相比于浏览器会自动缓存 Http 请求的内容，manifest 可以缓存没有被访问到的内容。

- 使用： `<html lang="en" manifest="index.manifest">`

- 文件格式

```bash
CACHE MANIFEST  # 固定格式，必须写在前面
# version 1.3

# 必须字段，标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径，无法使用通配符 *。
CACHE:
  test.css

# 可选，表示永远不会被缓存的文件，可以使用通配符 ＊。
NETWORK:
	*

# 可选，表示当资源无法访问时，使用指定的后备资源来替代。每条记录都列出两个 url，第一个表示当前页面，第二个表示后备页面，都必须使用相对路径
FALLBACK:
  /html5/ /404.html
  *.html /404.html
```

- 更新缓存的方法：
  - 更新 manifest 文件，比如可以修改版本号。
  - 通过 JS 操作。`window.applicationCache.update()` 会在每次打开页面时自动调用，去检查服务端有没有更新 manifest，我们也可以手动调用它来及时更新。
  - 清除浏览器缓存。

- 注意事项：
  - manifest 文件需要配置正确的 `MIME-type`，即 `text/cache-manifest`，必须在 web 服务器上进行配置。或者使用新的写法 `<html manifest="index.appcache">` 就不需要再进行服务端配置了。
  - 浏览器对缓存数据的容量限制可能不太一样，一些浏览器是每个站点 5MB。
  - 如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。
  - 引用 manifest 的 HTML 文件必须与 manifest 文件同源，在同一个域下。
  - FALLBACK 中的资源必须和 manifest 文件同源。
  - 站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。
  - （更推荐[使用 Service Worker 来做离线缓存](https://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/)）。

## 装饰器

装饰器一般是用来装饰类、类属性、类方法。使用装饰器可以做到不直接修改代码，就实现某些功能。

#### 类装饰器

装饰类的时候，装饰器方法一般会接收一个目标类作为参数。

```js
// 给目标类增加原型方法
const withSpeak = (targetClass) => {
  const prototype = targetClass.prototype;
  prototype.speak = function() {
    console.log('I can speak ', this.language);
  }
}

@withSpeak
class Student {
  constructor(language) {
    this.language = language;
  }
}
const student1 = new Student('Chinese');
student1.speak();   // I can speak  Chinese
```

利用高阶函数的属性，还可以给装饰器传参，通过参数来判断对类进行什么处理。

```js
// 返回一个函数，当做新的装饰器函数来装饰 Student 类（类似于函数柯里化）
const withLanguage = (language) => (targetClass) => {
  targetClass.prototype.language = language;
}

@withLanguage('Chinese')
class Student {}
const student = new Student();
student.language; // 'Chinese'
```


####  类属性装饰器

类属性装饰器可以用在类的属性、方法、get/set 函数中，一般会接收三个参数：target 表示被修饰的类、name 表示类成员的名字、descriptor 表示属性描述符（对象会将这个参数传给 `Object.defineProperty` 以此修饰 target 类）。使用类属性装饰器可以实现将类属性设置为只读（设置 `descriptor.writable = false`），或者统计一个函数的执行时间。

```js
function time(target, name, descriptor) {
  const func = descriptor.value;
  if (typeof func === 'function') {
    descriptor.value = function(...args) {
      console.time();
      const results = func.apply(this, args);
      console.timeEnd();
      return results;
    }
  }
}

class Person {
  @time
  say() {
    console.log('hello')
  }
}
const person = new Person();
person.say();
```

#### 装饰器的应用

1. 例如 [`core-decorators.js` 库](https://github.com/jayphelps/core-decorators)，常用在 React 中绑定类的 this。此外还有防抖和节流，简化了不少代码。

2. 实现多重继承。

```js
// targetClass 继承了 mixins 中的所有类
const mixin = (...mixins) => (targetClass) => {
  mixins = [targetClass, ...mixins];

  function copyProperties(target, source) {
    for (let key of Reflect.ownKeys(source)) {
      if (key !== 'constructor'
        && key !== 'prototype'
        && key !== 'name'
      ) {
        let desc = Object.getOwnPropertyDescriptor(source, key);
        Object.defineProperty(target, key, desc);
      }
    }
  }
  class Mixin {
    constructor(...args) {
      for (let mixin of mixins) {
        copyProperties(this, new mixin(...args)); // 拷贝实例属性
      }
    }
  }

  for (let mixin of mixins) {
    copyProperties(Mixin, mixin); // 拷贝静态属性
    copyProperties(Mixin.prototype, mixin.prototype); // 拷贝原型属性
  }
  return Mixin;
}
```

3. 用来对类的属性进行类型的校验。

```js
const rules = {
  name: 'string',
  password: 'string',
  age: 'number'
}

// 对 targetClass 类中的各个属性按 rules 进行类型校验
const validator = rules => targetClass => {
  return newProxy(targetClass, {
    construct(target, args) {
      const obj = new target(...args);
      for (let [name, type] of Object.entries(rules)) {
        if (typeof obj[name] !== type) {
          thrownewError(`${name} must be ${type}`)
        }
      }
      return obj;
    }
  })
}

@validator(rules)
class Person {
  name = 'tom'
  password = '123'
  age = '21'
}

const person = new Person();
```

## 正则表达式

#### 反斜杠

```js
const str = "rgb(51, 112, 255)";
const reg = new RegExp("rgb\(51, 112, 255\)", "g");
console.log(str.match(reg));  // 匹配不到，输出为 null

const str = "rgb(51, 112, 255)";
const reg = new RegExp("rgb\\(51, 112, 255\\)", "g");
console.log(str.match(reg));  // 这样就可以匹配到了
```

第一个例子匹配不到的原因在于，字符串里的 `\` 并不表示单纯的 `\` 字符，它有特殊意义，用于转义它后面的字符，所以 `new RegExp("rgb\(51, 112, 255\)", "g")` 被翻译成了 `/rgb(51, 112, 255)/g`，这里的 `()` 具有特殊含义，所以匹配不到。

所以需要用 `\\` 来将字符串中的 `\` 转义为单纯的 `\` 字符，这样就翻译成了 `/rgb\(51, 112, 255\)/g`，就可以转义括号了，也就能正常匹配到了。

```js
const str = '\\\\';
console.log(str);   // \\
console.log(str.match(new RegExp('\\\\', 'g')));  // [ '\\', '\\' ]
console.log(str.match(/\\/g));    // [ '\\', '\\' ]
```

#### ?= 和 ?!

`exp1(?=exp2)`：查找 exp2 前面的 exp1。

`(?<=exp2)exp1`：查找 exp2 后面的 exp1。

`exp1(?!exp2)`：查找后面不是 exp2 的 exp1。

`(?<!exp2)exp1`：查找前面不是 exp2 的 exp1。


## 图片懒加载实现方式

#### 监听 scroll

先不设置图片的 src，或者将其设置为 loading 的图片，而真实的图片 url 设置在 `data-src` 中。监听 scroll 事件，当图片节点出现在视图中时，就将 src 的值设置为 `data-src` 的值。


```js
// 判断图片是否出现在视图中
var clientHeight = document.documentElement.clientHeight;
var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
if(img.offsetTop < clientHeight + scrollTop) {
  if(img.getAttribute('src') === 'images/loading.gif') {
    img.src = img.getAttribute('data-src');
  }
}
```

因为滚动页面时，scroll 的监听函数触发频率很大，所以最好加个防抖操作。

#### IntersectionObserver API

使用 `IntersectionObserver` 这个 API 来自动实现懒加载。

> 参考 [IntersectionObserver API 使用教程](http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html)。

```js
// item 是一个数组，包含了被观察的并且可见性发生变化的节点，当节点的可见性发生变化时就会调用该回调函数
const io = new IntersectionObserver(function(items) {
  items.forEach(function(item) {
    const target = item.target;
    if(target.getAttribute('src') == 'images/loading.gif') {
      target.src = target.getAttribute('data-src');
    }
  })
});

imgDomArr.forEach(function(img) {
  // 添加要观察的 DOM 节点
  io.observe(img);
});
```

## PWA

- 简介：渐进式网页应用，集成了网页和 native app 的一些特点，包括：
  - 可以通过 url 分享。
  - 内容可以被搜索引擎搜索到。
  - 可以出现在设备的主屏幕而不用借助于浏览器，有利用增强用户粘性。
  - 可以在离线状态下运行（通过 Service Worker 实现的）。
  - 可以向设备发送通知。
  - 不用像 app 那样需要安装和更新，只需要刷新页面就可以了。

## Intelligence

> 这里记录一些对智力题的思考过程。不想再单独开一个菜单项了，就直接放着吧~

#### 取余制胜

Q：A 和 B 轮流拿硬币，每次最多只能拿 n 个，A 先手，怎么才可以拿到最后一个硬币？

A：A 要拿到最后一个，则需要在他倒数第二次拿的时候还剩 n+1 个硬币，这样无论 B 怎么拿 A 总能拿到最后一个。所以需要保证每轮 A 和 B 拿的硬币数量都是 n+1 的整数倍，也就是第一次拿的时候 A 要拿 `n % (n+1)` 个硬币，之后每次 B 拿多少个硬币，A 就拿相应的数量使两者之和凑到 n+1 即可。

思路总结：从后往前推，确定最后剩下多少个硬币时自己一定会获胜，然后再制定相应的策略。


#### n 匹马比赛求最后的前几名

Q：36 匹马分别在 6 个赛道比赛，每次比赛只知道名次而不知道具体的用时，如何快速决出前三名？

A：分三轮比赛：

第一轮：36 匹马分 6 组比赛，分别得到每场的第一名，6 组比赛分别按名次记为 A1、B1、C1、D1、E1、F1、A2、B2...

第二轮：A1、B1、C1、D1、E1、F1 进行比赛，得到前三名假如是 A1、B1、C1。结果只要前三名，所以已经可以排除掉所有 D、E、F 马匹了（D1、E1、F1 都没拿到前三，它们后面的自然也拿不到）。又因为 A1 已经连续两次第一，所以 A1 就是冠军了，此时只剩两个名额。而 C1 最好的成绩也只是第三名，所以 C2 和 C3 也可以排除掉了。

第三轮：现在只剩下 A2、A3、B1、B2、C1，进行一轮比赛可得到最后的季军和亚军。至此，前三名已经得到了，总共比赛次数是 6 + 1 + 1 = 8 次。


#### 时针分针形成的角度

Q：当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？

A：时针走一格是 30°，分针走一格是 6°，而分针每走一格对应的时针会走 0.5°（分针走一格表示过了 1/60 小时，1/60 * 30 = 0.5）。所以 m 点 n 分时，时针走了 30 * m + 0.5 * m，分针走了 6 * n，它们的夹角是 `|30 * m - 5.5 * n|`。但因为小时可能为 24 小时制，所以 m 需要去对 12 取余；以及形成的夹角可能是更大的那个，所以还需要再判断取小的那个。

```js
var angleClock = function(hour, minutes) {
  hour = hour % 12;
  const res = Math.abs(30 * hour - 5.5 * minutes);
  return Math.min(res, 360 - res);
};
```


#### 同时满足条件的占比

Q：一个班级 60% 喜欢足球，70% 喜欢篮球，80% 喜欢排球，问即三种球都喜欢占比有多少？

A：最多时有 60% 的人三种球都喜欢。根据题目可以知道有 40% 的人不喜欢足球，30% 的人不喜欢篮球，20% 的人不喜欢排球。所以最少的情况下，这里的 40%、30%、20% 中的人没有重复的，也就有 100% - 40% - 30% - 20% = 10% 的人都喜欢三种球。因此三种球都喜欢的人的占比为 10%-60%。


## 经典问题

- this、作用域、优先级等综合考察：

```js
function Foo() {
  getName = function () { alert (1); };
  return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}
 
//请写出以下输出结果：
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();

```

解析参考[这里](https://mp.weixin.qq.com/s/X40KEH37cRj01a_AuTzKrw)。


## 几个框架

- 共同的特性：
  - 使用 Virtual DOM 来优化页面性能。
  - 组件化思想，使项目模块化，易于维护和组件复用。
  - 响应式的数据。实现数据改变了自动更新视图。
  - 只提供核心功能，其他的功能如路由、状态管理器等交给其他的库实现，使用户选择性更高。

#### React 和 Vue

- 区别：
  - JSX VS Templates。JSX 使得编码更加自由，比如可以通过 JS 和临时变量来控制流程。



