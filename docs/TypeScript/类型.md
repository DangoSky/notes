# 类型

## const和readonly的区别

- const
    - 用于变量；
    - 变量不能重新赋值给其他任何事物。
- readonly
    - 用于属性；
    - 用于别名，可以修改属性；

```js
const foo: {
  readonly bar: number;
} = {
  bar: 123
};

function iMutateFoo(foo: { bar: number }) {
  foo.bar = 456;
}

// foo: { bar: number }并没有限定foo.bar不能修改
iMutateFoo(foo);
console.log(foo.bar); // 456
```

readonly只能确保被其约束的属性不被修改，如果该属性又被其他类型约束时则可以修改了。

```js
interface Foo {
  readonly bar: number;
}

let foo: Foo = {
  bar: 123
};

// 参数限定了是Foo的类型，所以foo.bar不能变
function iTakeFoo(foo: Foo) {
  foo.bar = 456; // Error: bar 属性只读
}

iTakeFoo(foo);
```

## 类型推论

```js
let myFavoriteNumber = 'seven';
myFavoriteNumber = 7;  // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'

// 等价于:
let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7;
```

如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型：

```js
let myFavoriteNumber;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
```

## 类型断言

类似于类型转换，为编译器提供关于如何分析代码的方法，但是不进行特殊的数据检查和解构。

```js
let someValue: any = "this is a string";
// 使用尖括号
let strLength: number = (<string>someValue).length;
// 使用 as。在TypeScript里使用JSX时，只能使用as语法断言
let strLength: number = (someValue as string).length;
```

## 类型别名

类型别名不会新建一个类型，它创建了一个新名字来引用那个类型，并且可以使用类型别名来在接口属性里引用自己。

```js
type StrOrNum = string | number;
let sample: StrOrNum;
sample = 123;
sample = '123';

type Index = 'a' | 'b' | 'c';
type FromIndex = { [k in Index]: number };
const bad: FromIndex = { b: 1, c: 2, d: 3 }; // Error: 对象字面量只能指定已知类型，'d' 不存在 'FromIndex' 类型上
```

类型别名不能被 extends 和 implements（自己也不能 extends 和 implements 其它类型），所以应该尽量使用接口。

## 非空断言

```js
interface Entity {
  name: string
}

function fn(e?: Entity) {
  let s = e!.name;
}
```

如果直接使用 `let s = e.name`;，编译器会抛出 e 可能不存在的错误。这时候可以使用非空断言 `!` 来表示 e 肯定是存在的，从而不会产生编译问题。

### keyof 和 typeof

- keyof T，索引类型查询操作符。 对于任何类型 T，`keyof T` 返回 T 的所有属性名。

```js
function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
  return names.map(n => o[n]);
}
```


## 类型保护

- 背景：对于类型联合，由于不确定变量的具体类型，所以不能确定它是否具有接口的属性/方法。

```js
interface Bird {
  fly();
  layEggs();
}

interface Fish {
  swim();
  layEggs();
}

function getSmallPet(): Fish | Bird {}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim();    // errors
```

- 自定义函数实现类型保护

  类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。自定义一个类型保护函数，它返回一个类型谓词。 谓词为 parameterName is Type 这种形式，parameterName 必须是来自于当前函数签名里的一个参数名。

```js
function isFish(pet: Fish | Bird): pet is Fish {
  return (<Fish>pet).swim !== undefined;
}

// 现在使用 'swim' 和 'fly' 调用都没有问题了
if (isFish(pet)) {
  pet.swim();
}
else {
  pet.fly();
}
```

- typeof实现类型保护

```js
function padLeft(value: string, padding: string | number) {
  if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
  }
  if (typeof padding === "string") {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}
```

## 类型兼容

- 对象的兼容

如果要让 x = y，则 y 的属性要**包含** x 的属性。

```js
interface Named {
  name: string;
}

let x: Named;
let y = { name: 'Alice', location: 'Seattle' };
x = y;  // ok 
```

- 函数的兼容

要使函数x = 函数y，则 y 的参数都需要能够在 x 里找到对应类型的参数，y 返回的数据要包含了 x 返回的数据。

```js
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

x = y; // Error
y = x; // OK
```


```js
let x = () => ({name: 'Alice'});
let y = () => ({name: 'Alice', location: 'Seattle'});

x = y; // OK
y = x; // Error because x() lacks a location property
```

- 类的兼容

比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。

```js
class Animal {
  feet: number;
  constructor(name: string, numFeet: number) { }
}
class Size {
  feet: number;
  constructor(numFeet: number) { }
}
let a: Animal;
let s: Size;

a = s;  //OK
s = a;  //OK
```

- 泛型的兼容

没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较，此时是兼容的。如果增加了一个泛型参数，因为其类型不同所以就不兼容了。

```js
interface Empty<T> {}
let x: Empty<number>;
let y: Empty<string>;
x = y;  // okay, y matches structure of x

interface NotEmpty<T> {
  data: T;
}
let x: NotEmpty<number>;
let y: NotEmpty<string>;
x = y;  // error, x and y are not compatible
```
