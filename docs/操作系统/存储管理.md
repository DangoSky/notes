# 存储管理

- 内存 / 主存：CPU 能直接存取指令和数据的存储器。对内存的访问是通过一系列对指定地址单元进行读或写来实现的（每个内存单元都有相应的内存地址，类似于数组中按下标来获取数组值）。

- 从用户源程序进入系统，到相应程序在机器上运行，要经历的主要处理阶段有编辑、编译、 连接、装入、运行。

- 逻辑地址空间 / 地址空间：由程序中逻辑地址（相对地址）组成的地址范围。

- 内存空间 / 物理空间 / 绝对空间：由内存中一系列存储单元所限定的地址范围.

- 重定位：程序和数据装入内存时，需对目标程序中的地址进行修改，把逻辑地址转变为内存物理地址（绝对地址）。
  - 静态重定位：在目标程序装入内存时，由装入程序对目标程序中指令和数据的逻辑地址都改成实际的内存地址。
    - 缺点：程序的存储空间只能是连续的一片区域，而且在重定位之后就不能再移动，不利于内存空间的有效使用。各个用户进程很难共享内存中的同一程序的副本。 
  - 动态重定位：在程序执行期间，每次访问内存之前进行重定位。需要靠硬件地址转换实现（一个存放起始地址的基址寄存器，一个存放用户程序逻辑地址最大范围的限长寄存器）。
    - 优点：程序占用的内存空间动态可变，并且不必连续存放在一处。比较容易实现几个进程对同一程序副本的共享使用。


## 分区法

- 分区分配：除操作系统占用内存的某个固定分区（通常是低址部分）外，把其余内存供用户程序使用，并且划分成若干分区，每个分区里容纳一个作业。

#### 固定分区法

- 固定分区就是内存中分区的个数固定不变，各个分区的大小也固定不变，每个分区只可装入一个进程。根据分区的大小是否相等，分为等分和查分方式两种固定分区方式。

- 缺点：要在系统生成时指定分区的个数，这就限制了系统中处于活动状态的进程数目。并且内存空间的利用率也不高。


#### 动态分区法

- 各个分区是在相应进程要进入内存时才建立的，使其大小恰好适应进程的大小。

- 使用一个内存登记表，记录内存中所有分区的大小、分区号、起始地址、使用状态，并由前后向指针连接起前后分区。

- 某个进程终止并释放它的分区后，如果恰好与其他空闲分区相邻接，则系统还要将它们合并起来使其成为一个连续更大的空闲区。

- 给一个进程分配分区时，若有多个容量满足要求的空闲内存区，则需要根据不同的分配算法选择不同的分区：
  - 最先适应算法：分配第一个满足要求的分区。使用这种算法时空闲表是按位置排列的，空闲块地址小的，在表中的序号也小。
    - 优点：便于释放内存时进行合并，且为大作业预留高址部分的大空闲区。
    - 缺点：内存高地址部分和低地址部分的利用不均衡，且会出现许多很小的空闲块，影响内存效率。
  - 最佳适应算法：尽量分配最小的空闲块。使用这种算法时空闲表是以空闲块的大小升序排列的，小块在前，大块在后。
    - 优点：产生的剩余块是最小的。
    - 缺点：不便于释放内存时与邻接区的合并，也同样会出现许多难以利用的小空闲块。
  - 循环适应算法：不从空闲表的开头查找，而从上次找到的可用分区的下一个空闲分区开始查找，从中选择满足大小要求的第一个空闲分区。
    - 优点：能使内存中的空闲块分布得更均匀，减少查找空闲块的开销。
    - 缺点：无法为大作业预留大的空闲块。

#### 碎片

- 内部碎片：在一个分区内部出现的碎片，如固定分区法。

- 外部碎片：在所有分区之外新增的碎片，如动态分区法。

- 紧缩 / 可重定位分区法：定时或在分配内存时把所有碎片合并为一个连续区。通过移动某些已分配区的内容（需要修改分区的信息），使所有进程的分区紧挨在一起，而把空闲区留在另一端。为了减少紧缩时进程的移动数量，在进程装入内存时，不是从上至下依次放置，而是采用 ”占两头 空中间“ 的办法。当紧缩时，各个进程按地址大小分别向两端靠拢，从而使空闲区保留在内存的中间部位。

- 紧缩的时机：
  - 当进程结束、释放所占用的分区时，如果它不与空闲区邻接就立即进行紧缩。
  - 在分配进程的分区时进行，即各个空闲区都不能满足该进程的需求时才进行紧缩。


## 分页

- 对换技术和分区技术要求必须把一个系统程序或用户程序装入一个连续的内存空间中。虽然使用紧缩可以提高内存利用率，但也花费了很多的 CPU 时间。而使用分页技术可以允许程序的存储空间不连续。

- 逻辑空间分页：将一个进程的逻辑地址空间划分成若干大小相等的部分，每个部分称做页面或页。每页都有一个编号叫做页号，页号从 0 开始依次编排。页面的大小是由系统确定的，它一般选择为 2 的若干次幂。

- 内存空间分块：把内存划分成与页面相同大小的若干存储块，称做内存块或页框。

- 逻辑地址表示：页号 + 页内地址。
  - 页号表示该地址所在页面的页号；页内地址表示页内位移。
  - 页号 = 逻辑地址 / 页面大小。页内地址 = 逻辑地址 % 页面大小。

- 页表：分页时，进程的页号连续但块号不连续。使用页表实现从页号到物理块号的地址映射（通常一个进程有一个页表）。

- 内存块表：记录每个内存块的分配情况。

- 分页系统中逻辑地址到物理地址的转换：页表都放在内存中。当进程需要访问某个逻辑地址中的数据时，分页地址映像硬件自动按页面大小将 CPU 得到的相对地址分成两部分：页号和页内地址。以页号为索引去检索页表（由硬件自动进行），从页表中得到该页的物理块号，把它装入物理地址寄存器中。同时将页内地址直接送入物理地址寄存器的块内地址字段中。这样，物理地址寄存器中的内容就是由二者拼接成的实际访问内存的地址。

- 页面越大的话，造成的内部碎片就越大；页面越小的话，需要的页面数就越多，需要用更大的页表， 同时页表寄存器的装入时间就越长。

- 页表通常都保存在内存中（但如果页表较小的话，也可以存储在寄存器中）。存取数据时需要访问两次内存，一次是访问页表确定数据的物理地址，另一次是根据这个物理地址存取数据或指令。

- 快表：记录最近使用过的页表表项。存取数据时先访问快表中是否存在该数据，不存在的话再访问页表。


### 页表构造

- 为避免页表太大，可以把页表分成若干较小的片段，离散地存放在内存中，并且只将当前需要的部分表项调入内存，其余的页表项根据需要动态地调入内存。

#### 多级页表

- 利用两级页表，把页表本身也分页，使每个页面的尺寸与物理内存块的大小相同。


![](./images/cunchuguanli/1.png)

其中，p1 是访问外层页表的索引，外层页表中的每一项是相应内层页表的起始地址。p2 是访问内层页表的索引，其中的表项是相应页面在内存中的物理块号。

![](./images/cunchuguanli/2.png)

- 地址转换过程是：利用外层页号 p1 检索外层页表，从中找到相应内层页表的基址。再利用 p2 作为该内层页表的索引，找到该页面在内存的块号。用该块号和页内地址 d 拼接起来，形成访问内存的物理地址。


#### 散列页表

![](./images/cunchuguanli/3.png)

- 以页号作为参数形成散列值。散列表中每一项有一个链表，它把有相同散列值的元素链接起来。每个链表元素由三部分组成：①：页号；②：对应的内存块号：③：指向链表中下一个元素的指针。

- 地址转换过程是：以逻辑地址中的页号 p 作为散列函数的参数，得到一个散列值，以它作为检索散列表的索引。把逻辑页号 p 与相应链表的第一个元素内表示页号的字段进行比较，如果匹配，则将相应的内存块号与逻辑地址中的页内地址拼接起来，形成访问内存的物理地址。否则就沿着链表指针向下搜索，直至找到匹配的页号。


#### 倒置页表

![](./images/cunchuguanli/4.png)


- 按内存块号排序的，每个内存块占有一个表项。每个表项包括：存放在该内存块中页面的虚拟页号、拥有该页面的进程标识符。这样系统中只有一个页表，每个内存块对应唯一的表项。

- 地址转换过程是：系统中每个虚拟地址由进程标识符 pid、虚拟页号 p 、页内地址 d 三部分组成，每个倒置页表的表项由进程标识符 pid 和虚拟页号 p 组成。当需要 访问地址时，就用进程标识符和页号去检索倒置页表。如果找到与之匹配的表项，则该表项的序号 i 就是该页在内存中的块号，块号 i 与逻辑地址中的页内地址 d 拼接起来就构成访问内存的物理地址。

- 倒置页表可减少页表占用的内存，却增加了检索页表时所耗费的时间，或许要查完整个页表才能找到匹配项。


#### 页面共享

- 有若干用户同时运行相同的程序时，为避免同时在内存中有同一页面的多个副本，可以使用页面共享，使这些相关进程的逻辑空间中的页指向相同的内存块（该块中放有共享程序或数据）。


## 分段

