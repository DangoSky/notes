# 调度

## 调度类型

- 一般来说，作业从进入系统到最后完成，可能要经历三级调度：高级调度、中级调度、低级调度。

#### 高级调度 / 作业调度 / 长期调度。

- 根据一定的算法，从输入的一批作业中选出若干作业，分配必要的资源如内存、外设等，为它建立相应的用户作业进程和为其服务的系统进程（如输入输出进程），最后把它们的程序和数据调入内存，等待进程调度程序对其执行调度，并在作业完成后做善后处理工作。

#### 中级调度 / 中期调度

- 在内存使用情况紧张时，将一些暂时不能运行的进程从内存对换到外存上等待。以后当内存有足够的空闲空间时，再将合适的进程重新换入内存，等待进程调度。

- 实际上就是存储管理中的对换功能，用于提高内存的利用率和系统吞吐量。

#### 低级调度 / 进程调度 / 短期调度

- 根据一定的算法，将 CPU 分派给就绪队列中的一个进程（真正决定哪个就绪进程是下一个得以执行的进程）。

- 进程调度程序：执行低级调度功能的程序，由它实现 CPU 在进程间的切换。


## 作业调度

- 作业状态： 在批处理系统中，用户的计算任务是按作业方式进行管理的。作业从提交给系统，直到它完成任务后退出系统前，分为提交、 后备、执行、完成 4 种状态。
  - 提交状态：用户向系统提交一个作业。
  - 后备状态：用户作业经输入设备（如读卡机）送入输入（磁盘）中存放，等待进入内存。
  - 执行状态：作业分配到所需的资源后被调入内存，且在 CPU 上执行相应的程序。
  - 完成状态：作业完成计算任务。

- 作业控制块 JCB：记录作业的有关信息，系统通过 JCB 实行对作业的管理和调度。

- 在磁盘输入中的所有后备作业按作业类型（CPU 型，I/O 型等）组成不同的后备作业队列，由作业调度从中挑选作业，随后放入内存并运行。

- 作业调度的主要任务是完成作业从后备状态到执行状态、从执行状态到完成状态的转换。

- 作业调度的任务：
  - 记录系统中各个作业的情况。
  - 按照某种调度算法从后备作业队列中挑选作业，决定接纳多少个作业进入内存和挑选哪些作业进入内存。
  - 为选中的作业分配内存和外设等资源。
  - 为选中的作业建立相应的进程，并把该进程放入就绪队列中。
  - 作业结束后进行善后处理工作，如输出必要的信息，收回该作业所占用的全部资源，撤消与该作业相关的全部进程和该作业的 JCB。（实际上，内存和外设的分配与释放分别由存储管理程序和设备管理程序完成，通过作业调度程序调用它们来实现）

- 作业调度的时机：
  - 一个作业终止时。
  - CPU 的空转时间超过某个限度时。


## 进程调度

- 进程调度的作用：
  - 保存现场。
  - 挑选进程。
  - 恢复现场。

- 进程调度的时机：
  - 创建进程时。
  - 进程终止时。
  - 等待事件时。
  - 中断发生时。
  - 时间片用完时。

- 进程调度的方式：
  - 非抢占方式。
  - 抢占方式。

#### 两级调度模型

- 作业调度和进程调度是 CPU 主要的两级调度。作业调度是宏观调度，它所选择的作业只具有获得处理机的资格，但尚未占有处理机不能立即投入运行。而进程调度是微观调度，它根据一定的算法动态地把处理机实际地分配给所选择的进程，使之真正活动起来。

- 作业调度和进程调度的区别：
  - 一个基本区别是它们执行的频率不同，进程调度必须相当频繁地为 CPU 选择进程。
  - 作业调度执行的次数很少。作业调度控制程序的道数（即内存中进程的数目），如果系统中作业道数保持不变，那么进入系统的作业的平均到达速率就一定等于离开系统的作业的平均离去速率。
  - 在某些系统中可以没有作业调度。例如在分时系统中，往往没有作业调度程序，而是简单地把每个新进程装入内存，供进程调度程序使用。

![](./images/diaodu/1.png)


## 调度性能准则

- CPU 利用率。
- 吞吐量：表示单位时间内 CPU 完成作业的数量。
- 周转时间：从作业提交到作业完成的时间间隔。周转时间是作业等待进入内存、进程在就绪队列中等待、进程在 CPU 上执行和完成 I/O 操作所花费时间之和。（周转时间通常受到输出设备速度的限制）
  - 平均周转时间：完成 n 个作业的平均周转时间，可以衡量不同调度算法对相同作业流的调度性能。
  - 带权周转时间：用来合理地反映长短作业的差别（因为作业周转时间没有区分作业实际运行时间长短的特性）。带权周转时间 W = T / R（ T 为周转时间，R 为实际运行时间）。
  - 平均带权周转时间：完成 n 个作业的平均带权周转时间，可以比较某种调度算法对不同作业流的调度性能。
- 就绪等待时间：CPU 调度算法并不真正影响作业执行或 I/O 操作的时间数量。各种 CPU 调度算法仅影响作业或进程在就绪队列中所花费的时间数量。
- 响应时间：提交第 1 个请求到产生第 1 个响应所用的时间。


## 调度算法

#### 先来先服务法 FCFS

- 把 CPU 优先分配给最先达到的作业或进程。

- FCFS 调度算法对 CPU 繁忙型作业（需要大量 CPU 时间进行计算的作业）较有利，而不利于 I/O 繁忙型作业（需要频繁请求 I/O 的作业）。

#### 短作业优先法 SJF

- 把 CPU 优先分配给运行时间最短的作业。如果两个进程有相同的估计运行时间，就根据先来先服务法处理。

- 缺点：对长作业很不利。

#### 最短剩余时间优先法 SRTF

- 采用抢占式策略。当新进程加入就绪队列时，如果它需要的运行时间比当前运行的进程所需的剩余时间还短，则强行剥夺 CPU 的控制权，调度该新进程运行。

- 缺点：增加系统开销，如保存进程断点现场、统计进程剩余时间等。


#### 优先级法

- 把 CPU 优先分配给优先级最高的进程。如果在运行过程中，就绪队列中出现优先级更高的进程时，可以选用非抢占式优先级法或者抢占式优先级法。

- 优先级的确定方式：
  - 静态优先级是在创建进程时就确定下来的，而且在进程的整个运行期间保持不变。但可能会造成饥饿锁。
  - 动态优先级是随着进程的推进而不断改变的。解决低优先级进程饥饿锁的一种办法可以是，使系统中等待 CPU 很长时间的进程逐渐提升其优先级。（UNIX 系统中优先数小、优先级高）。

#### 轮转法 RR

- 把所有就绪进程按先入先出的原则排成一个队列，新来的进程则加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在 CPU 上运行一个时间片的时间。用完后系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾，之后再分配给队首进程一个时间片时间运行，如此往复。

- 时间片的长短的确定因素：
  - 系统的响应时间。在进程数目一定时，时间片的长短直接正比于系统对响应时间的要求。
  - 就绪队列进程的数目。当系统要求的响应时间一定时，时间片的大小反比于就绪队列中的进程数。
  - 进程的转换时间。若执行进程调度时的转换时间为 t，时间片为 q，应使比值 t / q 不大于某一数值。
  -  CPU 运行指令速度。CPU 运行速度快，则时间片可以短些；反之则应取长些。


#### 多级队列法 MQ

- 把就绪队列划分成几个单独的队列，一般根据进程的某些特性如占用内存大小、进程优先级、进程类型等，永久性地把各个进程分别链入不同的队列中，每个队列都有自己的调度算法。在各个队列之间通常采用固定优先级的抢占式调度。或者各个队列也可以规定时间比例，即每个队列都取得一定的 CPU 时间片段，然后调度本队列中的各个进程。

#### 多级反馈队列法 MFQ

- 实现思想：
  - 系统中设置多个就绪队列，每个队列对应一个优先级，第 1 个队列的优先级最高，以下各个队列的优先级逐个降低。
  - 各就绪队列中进程的运行时间片不同，高优先级队列的时间片小，低优先级队列的时间片大。从高到低 依次加倍。
  - 新进程进入系统后，先放入第 1 个队列的末尾。如某个进程在相应时间片内没有完成工作，则把它转到下一个队列的末尾，直至进入最后一个队列。
  - 系统先运行第 1 个队列中的进程，第 1 个队列为空后，才运行第 2 个队列中的进程，依此类推。

- 也会存在饥饿锁问题，解决办法是提升在低优先级队列中等待了很长时间的进程的优先级。

- 多级反馈队列法是最通用的 CPU 调度算法。


#### 高响应比优先法 HRRF

- 为每个进程计算一个响应比 RR = (w + s) / s = w / s + 1（w 是进程等待处理机所用的时间，相当于到达时间；s 是进程要求的服务时间）。在调度进行时，以各进程的响应比作为其优先级，从中选出级别最高的进程投入运行。

- 利于短作业（进程）。而对于长进程，随着其等待时间的延长，相应的优先级可以上升，从而避免了饥饿锁问题。


#### 公平共享法 FS

- 系统为每个用户分配一定比例的 CPU 时间，然后按照这个比例在各用户之间挑选相应的进程。可以防止不同用户创建的进程数量差别很大，而导致进程数多的用户占用更多 CPU 时间的情况。


![](./images/diaodu/2.png)


## 线程调度

- 用户级线程：核心不负责线程的调度，只调度进程，由进程内部的线程调度程序决定让哪个线程运行。

- 核心级线程：由核心调度线程。

- 用户级线程和核心级线程的主要区别：
  - 性能。用户级线程切换可用机器指令，速度快。而核心级线程切换需要全部上下文切换，因而速度慢。
  - 挂起。核心级线程方式下，一个线程因等待 I/O 而阻塞时，不会挂起整个进程。而用户级线程方式下却会挂起整个进程。


## 多处理器调度

- 多处理器系统的类型：
  - 松散耦合多处理器系统 / 集群系统：每台处理器有自己的内存和 I/O 通道，每台处理器上有自己的操作系统。
  - 主从多处理器系统： 操作系统和它的表格只放在一个称做主控机的处理器上，而其他处理器是从机。主控机控制各从机的工作和执行 I/O 操作，而从机仅运行用户进程，为主控机提供服务。所有的系统调用都重定向到主控机，由它予以处理。
  - 紧密耦合多处理器系统：一组处理器共享一个内存，并且在一个操作系统的集中控制下工作。每个处理器都可控制 I/O 设备或对内存单元进行访问，但任何时候只能有一个处理器正在执行。

- 多处理器系统中的线程调度方式：
  - 负载共享。不把进程分给具体的处理器，系统维护一个全局的就绪线程队列，当某个处理器空闲时，就从该队列中选择一个线程。
  - 成组调度。把一组相关线程作为一个单位同时调到一组处理器上运行，所有成组线程一起开始和结束它们的时间片。
  - 专用处理器分配：当一个进程被调度时，它的每个线程被分配到一个处理器上，在该进程完成之前，处理器由相应的线程专用。
  - 动态调度：允许在进程执行期间动态改变其线程的数目。操作系统的调度职责主要限于处理器的分配。


