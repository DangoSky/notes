(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{354:function(t,e,r){t.exports=r.p+"assets/img/1.dc6eeedf.png"},355:function(t,e,r){t.exports=r.p+"assets/img/2.7c087f6b.png"},456:function(t,e,r){"use strict";r.r(e);var o=r(42),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"生命周期"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),o("blockquote",[o("p",[t._v("官方文档"),o("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-component.html#commonly-used-lifecycle-methods",target:"_blank",rel:"noopener noreferrer"}},[t._v("见这里"),o("OutboundLink")],1),t._v("。")])]),t._v(" "),o("h2",{attrs:{id:"constructor"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),o("ul",[o("li",[t._v("使用：初始化 state 和 props。（只会执行一次）。")])]),t._v(" "),o("h2",{attrs:{id:"componentwillmount"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#componentwillmount"}},[t._v("#")]),t._v(" componentWillMount")]),t._v(" "),o("ul",[o("li",[t._v("使用：可以调用 setState 方法来改变状态值。")]),t._v(" "),o("li",[t._v("注意点：\n"),o("ul",[o("li",[t._v("这方法里同步地设置状态将不会触发重渲染。")]),t._v(" "),o("li",[t._v("无法获取页面中的DOM对象。")])])]),t._v(" "),o("li",[t._v("不推荐使用，要被废弃了。")])]),t._v(" "),o("h2",{attrs:{id:"render"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[t._v("#")]),t._v(" render")]),t._v(" "),o("ul",[o("li",[t._v("注意点：\n"),o("ul",[o("li",[t._v("不要在 render 方法中调用 setState 方法，否则会递归渲染导致报错。")]),t._v(" "),o("li",[t._v("无法获取页面中的DOM对象。")])])])]),t._v(" "),o("h2",{attrs:{id:"componedidmount"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#componedidmount"}},[t._v("#")]),t._v(" componeDidMount")]),t._v(" "),o("ul",[o("li",[t._v("触发条件：组件挂载后（插入 DOM 树中）立即调用，此时页面还没有渲染出来。")]),t._v(" "),o("li",[t._v("使用：可以进行DOM操作和网络请求。")])]),t._v(" "),o("h2",{attrs:{id:"componentwillreceiveprops-nextprops"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#componentwillreceiveprops-nextprops"}},[t._v("#")]),t._v(" componentWillReceiveProps(nextProps)")]),t._v(" "),o("ul",[o("li",[t._v("触发条件：组件要从父组件接受新的props，并且该组件不是第一次被渲染出来。")]),t._v(" "),o("li",[t._v("不推荐使用，要被废弃了。")])]),t._v(" "),o("h2",{attrs:{id:"shouldcomponentupdate-nextprops-nextstate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate-nextprops-nextstate"}},[t._v("#")]),t._v(" shouldComponentUpdate(nextProps, nextState)")]),t._v(" "),o("ul",[o("li",[t._v("触发条件：组件更新之前触发，默认返回 true。如果返回 false 则不再继续后面的生命周期钩子也就不会render（返回 false 并不会阻止子组件在 state 更改时重新渲染）。首次渲染或使用 forceUpdate() 时不会调用该方法。")]),t._v(" "),o("li",[t._v("使用：可以通过比较新的 props 和旧的 props 中值是否更新来控制是否重新渲染。避免因为props变化了而子组件数据没有改变却依旧要执行render造成的性能浪费。")])]),t._v(" "),o("h2",{attrs:{id:"componentwillupdate-nextprops-nextstate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#componentwillupdate-nextprops-nextstate"}},[t._v("#")]),t._v(" componentWillUpdate(nextProps, nextState)")]),t._v(" "),o("ul",[o("li",[t._v("触发条件：组件更新之前。只有 "),o("code",[t._v("shouldComponentUpdate")]),t._v(" 返回 true 才会执行。")]),t._v(" "),o("li",[t._v("不推荐使用，要被废弃了。")])]),t._v(" "),o("h2",{attrs:{id:"componentdidupdate-prevprops-prevstate-snapshot"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#componentdidupdate-prevprops-prevstate-snapshot"}},[t._v("#")]),t._v(" componentDidUpdate(prevProps, prevState, snapshot)")]),t._v(" "),o("ul",[o("li",[t._v("触发条件：在更新后会被立即调用，首次渲染不会执行此方法。")]),t._v(" "),o("li",[t._v("注意：可以在 "),o("code",[t._v("componentDidUpdate")]),t._v(" 中直接调用 setState()，但它必须被包裹在一个条件语件里，否则会导致死循环，因为每次更新都会调用到 "),o("code",[t._v("componentDidUpdate")]),t._v("。")]),t._v(" "),o("li",[t._v("snapshot参数：如果组件实现了 "),o("code",[t._v("getSnapshotBeforeUpdate")]),t._v(" 生命钩子，则它的返回值将作为 "),o("code",[t._v("componentDidUpdate")]),t._v(" 的第三个参数 snapshot，否则此参数将为 undefined。")])]),t._v(" "),o("h2",{attrs:{id:"componentwillunmount"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#componentwillunmount"}},[t._v("#")]),t._v(" componentWillUnmount")]),t._v(" "),o("ul",[o("li",[t._v("使用：清除定时器，取消网络请求。")])]),t._v(" "),o("h2",{attrs:{id:"getderivedstatefromprops-nextprops-prevstate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#getderivedstatefromprops-nextprops-prevstate"}},[t._v("#")]),t._v(" getDerivedStateFromProps(nextProps, prevState)")]),t._v(" "),o("ul",[o("li",[t._v("触发条件：在 render 之前调用，并且在初始挂载及后续更新时都会被调用。")]),t._v(" "),o("li",[t._v("使用：返回一个对象来更新 state，如果返回 null 则不更新任何内容。而 "),o("code",[t._v("componentWillReceiveProps")]),t._v(" 仅在父组件重新渲染时触发，而不是在内部调用 setState 时。")]),t._v(" "),o("li",[t._v("注意："),o("code",[t._v("getDerivedStateFromProps")]),t._v(" 是一个静态函数，所以不能通过 this 访问到 class 的属性，即无法访问组件实例。")])]),t._v(" "),o("h2",{attrs:{id:"getsnapshotbeforeupdate-prevprops-prevstate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#getsnapshotbeforeupdate-prevprops-prevstate"}},[t._v("#")]),t._v(" getSnapshotBeforeUpdate(prevProps, prevState)")]),t._v(" "),o("ul",[o("li",[t._v("触发条件：在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据。其返回值将作为参数传递给 "),o("code",[t._v("componentDidUpdate")]),t._v("。")])]),t._v(" "),o("h2",{attrs:{id:"static-getderivedstatefromerror-error"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#static-getderivedstatefromerror-error"}},[t._v("#")]),t._v(" static getDerivedStateFromError(error)")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("触发条件：在后代组件抛出错误后被调用。它将抛出的错误作为参数，并返回一个值以更新 state。")])]),t._v(" "),o("li",[o("p",[t._v("注意："),o("code",[t._v("getDerivedStateFromError")]),t._v(" 会在渲染阶段调用，因此不允许出现副作用。")])])]),t._v(" "),o("h2",{attrs:{id:"componentdidcatch-error-info"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#componentdidcatch-error-info"}},[t._v("#")]),t._v(" componentDidCatch(error, info)")]),t._v(" "),o("ul",[o("li",[t._v("触发条件：在后代组件抛出错误后被调用。它接收两个参数：\nerror： 抛出的错误。\ninfo：带有"),o("code",[t._v("componentStack key")]),t._v(" 的对象，其中包含有关组件引发错误的栈信息。")])]),t._v(" "),o("h2",{attrs:{id:"示意图"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#示意图"}},[t._v("#")]),t._v(" 示意图")]),t._v(" "),o("p",[o("a",{attrs:{href:"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/",target:"_blank",rel:"noopener noreferrer"}},[t._v("图谱"),o("OutboundLink")],1),t._v("。")]),t._v(" "),o("p",[o("img",{attrs:{src:r(354),alt:""}})]),t._v(" "),o("p",[o("img",{attrs:{src:r(355),alt:""}})]),t._v(" "),o("h2",{attrs:{id:"执行流程"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[t._v("#")]),t._v(" 执行流程")]),t._v(" "),o("h3",{attrs:{id:"挂载"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#挂载"}},[t._v("#")]),t._v(" 挂载")]),t._v(" "),o("p",[t._v("当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：")]),t._v(" "),o("ol",[o("li",[o("code",[t._v("constructor")])]),t._v(" "),o("li",[o("code",[t._v("static getDerivedStateFromProps")])]),t._v(" "),o("li",[o("code",[t._v("render")])]),t._v(" "),o("li",[o("code",[t._v("componentDidMount")])])]),t._v(" "),o("h3",{attrs:{id:"更新"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),o("p",[t._v("当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：")]),t._v(" "),o("ol",[o("li",[o("code",[t._v("static getDerivedStateFromProps")])]),t._v(" "),o("li",[o("code",[t._v("shouldComponentUpdate")])]),t._v(" "),o("li",[o("code",[t._v("render")])]),t._v(" "),o("li",[o("code",[t._v("getSnapshotBeforeUpdate")])]),t._v(" "),o("li",[o("code",[t._v("componentDidUpdate")])])]),t._v(" "),o("h3",{attrs:{id:"错误处理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[t._v("#")]),t._v(" 错误处理")]),t._v(" "),o("p",[t._v("当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：")]),t._v(" "),o("ol",[o("li",[o("code",[t._v("static getDerivedStateFromError")])]),t._v(" "),o("li",[o("code",[t._v("componentDidCatch")])])]),t._v(" "),o("h3",{attrs:{id:"渲染"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#渲染"}},[t._v("#")]),t._v(" 渲染")]),t._v(" "),o("p",[t._v("只要 state 或 props 改变了（即使是赋相同的值），就会调用 "),o("code",[t._v("render")]),t._v(" 函数渲染组件，之后进行 DOM diff。使用 pure Component 可以进行浅层次的比较，防止无谓的渲染（或者手动使用 "),o("code",[t._v("shouldComponentUpdate")]),t._v("）。")]),t._v(" "),o("p",[t._v("或者使用 "),o("code",[t._v("component.forceUpdate(callback)")]),t._v(" 强制组件调用 render 刷新。此操作会跳过该组件的 "),o("code",[t._v("shouldComponentUpdate")]),t._v("，但还是会触发正常的生命周期方法。")])])}),[],!1,null,null,null);e.default=a.exports}}]);