(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{469:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"中间层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中间层"}},[t._v("#")]),t._v(" 中间层")]),t._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("p",[t._v("通常的前后端分工是：前端负责用户界面，而后端负责提供数据和业务接口。有了 Node 后我们可以在两者间加入一层，前端并不是直接去请求后端业务接口，而是请求到中间层。再由中间层去请求业务接口。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://github.com/pubdreamcc/Node.js/raw/master/node%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/60.jpg",alt:""}})]),t._v(" "),s("p",[t._v("整个流程可以描述为：客户端直接请求到中间层的Node服务，Node服务分析请求，看需要哪个页面，再去请求对应数据，拿到数据后和模版结合成用户看到页面，再给到客户端。")]),t._v(" "),s("h2",{attrs:{id:"中间层的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中间层的优点"}},[t._v("#")]),t._v(" 中间层的优点")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("减轻客户端内存，项目用户体验好。不会像mvvm模式的项目把页面渲染和数据请求都压在客户端，而是在服务端完成。")])]),t._v(" "),s("li",[s("p",[t._v("SEO性好，不像mvvm模式页面由js生成，而是在服务器渲染好html 字符，有利于网页被搜索到。")])]),t._v(" "),s("li",[s("p",[t._v("保持了前后端分离的优点和目的，即解放后端，后端可以继续以接口的形式写业务代码。")])]),t._v(" "),s("li",[s("p",[t._v("前端可以操控的范围增多，甚至可以做服务器，数据库层面的优化，比如中间层中常常用nginx，redis来优化项目，应对高并发。")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);