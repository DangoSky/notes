(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{458:function(t,a,v){"use strict";v.r(a);var _=v(42),i=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"虚拟-dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[t._v("#")]),t._v(" 虚拟 DOM")]),t._v(" "),v("p",[t._v("template/JSX -> Render Function -> Vnode（做 Diff）-> DOM")]),t._v(" "),v("h2",{attrs:{id:"虚拟-dom-的优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-的优势"}},[t._v("#")]),t._v(" 虚拟 DOM 的优势")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("非绝对上的速度优势。diff 算法比对虚拟 DOM 中需要变更的部分节点并更新，而非更新整个视图。不过如果整个 DOM 都更新了的话，使用虚拟 DOM 不仅一样要绘制渲染整个视图，而且还要进行 diff 算法，就不一定会更快了。")])]),t._v(" "),v("li",[v("p",[t._v("虚拟 DOM 只会在比对后修改一次真实 DOM，所以不会有大量的重排重绘消耗，而且可以只渲染局部。")])]),t._v(" "),v("li",[v("p",[t._v("使跨平台渲染成为可能。比如说 Node 里没有 DOM，如果想实现 SSR 的话，就可以借助虚拟 DOM，因为虚拟 DOM 本身只是一个 JavaScript 对象。而对于小程序和 APP，也可以用 JS 写虚拟 DOM 表示 UI，再由原生实现去渲染页面。")])])]),t._v(" "),v("h2",{attrs:{id:"虚拟-dom-的渲染流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-的渲染流程"}},[t._v("#")]),t._v(" 虚拟 DOM 的渲染流程")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("将页面的真实 DOM 抽象成一个 JS 对象，包含了节点标签、节点的属性和子元素（所以其实虚拟 DOM 就只是一个 JS 对象）。")])]),t._v(" "),v("li",[v("p",[t._v("数据改变时，将新的真实 DOM 抽象成另一个 JS 对象。")])]),t._v(" "),v("li",[v("p",[t._v("采用深度优先遍历新旧两个虚拟 DOM，用一个唯一的 ID 标志每个节点，并比对两者的差别，将变化的类型、新值记录、节点 ID 记录在一个补丁数组里。节点的变化只有文本变化、属性变化、节点增删移动几种情况。")])]),t._v(" "),v("li",[v("p",[t._v("根据补丁数组去修改需要更新的 DOM 节点。")])])]),t._v(" "),v("h2",{attrs:{id:"diff-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" diff 算法")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("diff 算法的优化：")]),t._v(" "),v("ul",[v("li",[t._v("同级比对，只比较新旧虚拟 DOM 中同个层级的节点。")]),t._v(" "),v("li",[t._v("同级相同节点位置变了可以复用（通过 key 来复用）。")])])]),t._v(" "),v("li",[v("p",[t._v("TODO：具体的 diff 流程和优化策略待日后补充。")])])]),t._v(" "),v("h2",{attrs:{id:"faq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[t._v("#")]),t._v(" FAQ")]),t._v(" "),v("ol",[v("li",[t._v("为什么使用深度优先遍历而不是广度优先遍历？")])]),t._v(" "),v("p",[t._v("深度遍历使用到的是栈结构，深度遍历的时候，栈中保留的是当前节点的父元素和祖先元素，栈中存储的节点数就是树的深度值，占用的空间比较少。而广度遍历使用的是队列结构，广度遍历按树的层级来遍历，队列中保存的是下一层的节点，数量是树的广度值，占用的空间会更大。")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("diff 算法时间复杂度如何从 O(n^3) 优化到 O(n)？")])]),t._v(" "),v("p",[t._v("原来的 diff 算法，是将旧虚拟 DOM 的每个节点和新虚拟 DOM 的每个节点进行比较，这就已经有 O(n^2) 了。但考虑到实际应用中跨层级的 DOM 节点改变很少，所以现在的 diff 算法只是比较同层级的节点，也就下降到了 O(n)。")])])}),[],!1,null,null,null);a.default=i.exports}}]);