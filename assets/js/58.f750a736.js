(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{465:function(t,e,o){"use strict";o.r(e);var a=o(42),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"v3-和-v4-的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#v3-和-v4-的区别"}},[t._v("#")]),t._v(" V3 和 V4 的区别")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("V3 的路由规则是“排他性”的，这意味着只有一条路由将获胜。V4 的路由默认为“包含”的，这意味着多个 "),o("code",[t._v("<Route>")]),t._v(" 可以同时进行匹配和渲染。所以就有了 exact 属性。")])]),t._v(" "),o("li",[o("p",[t._v("React-RouterV3 跳转路由可以通过导出 browserHistory，使用 "),o("code",[t._v("browserHistory.push(path)")]),t._v(" 的方法操作路由跳转。但 V4 不提供 browserHistory 等的导出。")])]),t._v(" "),o("li",[o("p",[t._v("V3的 path 可选是用 () 来表示，如："),o("code",[t._v('<Route path="to/page(/:pathParam)" component={MyPage} />')]),t._v("， V4 是用 ？ 来表示，如："),o("code",[t._v('<Route path="/:id(login)?" exact component={login} />')]),t._v("。")])]),t._v(" "),o("li",[o("p",[t._v("V3 可以使用 "),o("code",[t._v("<IndexRoute />")]),t._v("来当作默认路由（如果匹配了它的父级路由，又匹配不到任何同级路由，则渲染该路由），在 V4 中废弃。")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);