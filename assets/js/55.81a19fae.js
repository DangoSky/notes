(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{467:function(t,a,s){"use strict";s.r(a);var r=s(42),l=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"服务端渲染和客户端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染和客户端渲染"}},[t._v("#")]),t._v(" 服务端渲染和客户端渲染")]),t._v(" "),s("h2",{attrs:{id:"服务端渲染-ssr"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染-ssr"}},[t._v("#")]),t._v(" 服务端渲染（SSR）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("简单理解就是浏览器发送请求后，服务器把客户端网页和数据在后台渲染解析，之后把渲染后的结果返回客户端。")])]),t._v(" "),s("li",[s("p",[t._v("优点：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("不需要先下载一堆 js 和 css 后才能看到页面，可以解决首页白屏时间过久，但是也容易导致服务器压力大，因此，可以使用服务器端的页面缓存技术，减轻服务器的渲染压力。")])]),t._v(" "),s("li",[s("p",[t._v("SEO。客户端拿到的是渲染后的结果可以直接展示。服务器端渲染的页面在网络中传输的时候，传输的是一个真实的页面。因此，爬虫客户端当爬到我们的页面后，我们页面中的关键数据就会被爬虫给收录了。")])]),t._v(" "),s("li",[s("p",[t._v("服务端渲染不用关心浏览器兼容性问题（随着浏览器发展，这个优点逐渐消失）。")])])])])]),t._v(" "),s("h2",{attrs:{id:"客户端渲染-csr"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#客户端渲染-csr"}},[t._v("#")]),t._v(" 客户端渲染（CSR）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("客户端渲染简单理解就是浏览器发送页面请求，服务器返回的是一个模板页面，浏览器从上至下解析过程中需要发送ajax请求获取数据，最后再调用模板引擎（art-template等）渲染HTML结构，并把渲染后的结果添加到页面指定容器中。")])]),t._v(" "),s("li",[s("p",[t._v("优点：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("懒加载。如在页面初始时只加载可视区域内的数据，滚动后rp加载其它数据，可以通过 react-lazyload 实现")])]),t._v(" "),s("li",[s("p",[t._v("节约服务器成本。省电省钱，JS 支持 CDN 部署，且部署极其简单，只需要服务器支持静态文件即可。")])]),t._v(" "),s("li",[s("p",[t._v("局部刷新。无需每次都进行完整页面请求。")])]),t._v(" "),s("li",[s("p",[t._v("客户端渲染因为数据是异步获取，所以在展示完整页面的过程中最少发起两次请求。数据是动态的添加到页面中，因此非常不利于SEO。")])])])])])])}),[],!1,null,null,null);a.default=l.exports}}]);