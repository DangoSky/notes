(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{420:function(t,s,a){"use strict";a.r(s);var e=a(42),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-router4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-router4"}},[t._v("#")]),t._v(" React-Router4")]),t._v(" "),a("h2",{attrs:{id:"路由匹配规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由匹配规则"}},[t._v("#")]),t._v(" 路由匹配规则")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("{参数名}")]),t._v("：匹配 URL 的一个部分，直到遇到下一个 "),a("code",[t._v("/")]),t._v("、"),a("code",[t._v("?")]),t._v("、"),a("code",[t._v("#")]),t._v(" 为止。这个路径参数可以通过 "),a("code",[t._v("this.props.params.paramName")]),t._v(" 取出。")]),t._v(" "),a("li",[a("code",[t._v("()")]),t._v("：表示 URL 的这个部分是可选的。")]),t._v(" "),a("li",[a("code",[t._v("-")]),t._v("：匹配任意字符，直到下一个 "),a("code",[t._v("/")]),t._v("、"),a("code",[t._v("?")]),t._v("、"),a("code",[t._v("#")]),t._v(" 为止。匹配方式是非贪婪模式。")]),t._v(" "),a("li",[a("code",[t._v("--")]),t._v("： 匹配任意字符，直到下一个 "),a("code",[t._v("/")]),t._v("、"),a("code",[t._v("?")]),t._v("、"),a("code",[t._v("#")]),t._v(" 为止。匹配方式是贪婪模式。")]),t._v(" "),a("li",[t._v("path 属性也可以使用相对路径（不以 / 开头），匹配时就会相对于父组件的路径。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Route path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/hello(/:name)"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匹配 /hello")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匹配 /hello/michael")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匹配 /hello/Ryan")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Route path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/files/-"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匹配 /files/ ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匹配 /files/a")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匹配 /files/a/b")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Route path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/--/-.jpg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匹配 /files/hello.jpg")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匹配 /files/path/to/file.jpg")]),t._v("\n")])])]),a("h2",{attrs:{id:"提供的组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提供的组件"}},[t._v("#")]),t._v(" 提供的组件")]),t._v(" "),a("h4",{attrs:{id:"route"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#route"}},[t._v("#")]),t._v(" Route")]),t._v(" "),a("p",[a("code",[t._v("<Route path=“xxx” component={Home} />")]),t._v(" 根据匹配 path 决定是否显示 Home 组件，还可以接收 exact 和 strict 属性。若是省略 path 属性，则不管路径是否匹配，都会加载指定的组件，所以可以用来充当 404 路由。")]),t._v(" "),a("h4",{attrs:{id:"switch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#switch"}},[t._v("#")]),t._v(" Switch")]),t._v(" "),a("p",[a("code",[t._v("<Switch />")]),t._v(" 只匹配第一个匹配到的路由，子节点只能是 "),a("code",[t._v("<Route>")]),t._v(" 或 "),a("code",[t._v("<Redirect>")]),t._v(" 组件。")]),t._v(" "),a("h4",{attrs:{id:"redirect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redirect"}},[t._v("#")]),t._v(" Redirect")]),t._v(" "),a("p",[a("code",[t._v('<Redirect to="/login" />')]),t._v(" 重定向到该组件。对于未登录态，可直接在 render 方法中判断并返回 "),a("code",[t._v("<Redirect />")]),t._v(" 组件来跳转到登陆页面。用在 "),a("code",[t._v("<Router />")]),t._v(" 组件中也可以放在最后用于没有匹配到任一路由时重定向到该路由。")]),t._v(" "),a("h4",{attrs:{id:"prompt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prompt"}},[t._v("#")]),t._v(" Prompt")]),t._v(" "),a("p",[a("code",[t._v("<Prompt />")]),t._v(" 用来在跳转导航时弹出确认框。")]),t._v(" "),a("h2",{attrs:{id:"exact-和-strict-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exact-和-strict-属性"}},[t._v("#")]),t._v(" exact 和 strict 属性")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Route 的 exact 属性，设为 true 是开启严格匹配，只有 url 严格匹配 path 时才匹配路由。在 exact 为 true 下，"),a("code",[t._v("/link")]),t._v(" 与 "),a("code",[t._v("/")]),t._v(" 是不匹配的；但是在 exact 为 false 时它们则匹配。")])]),t._v(" "),a("li",[a("p",[t._v("Route 的 strict 属性，设为 true 表示只有当访问地址后缀斜杠严格匹配（有或无）时才匹配路由。在 strict 为 true 下，"),a("code",[t._v("/one/")]),t._v(" 与 "),a("code",[t._v("/one")]),t._v(" 是不匹配的，但可以匹配 "),a("code",[t._v("/one/two")]),t._v("。")])])]),t._v(" "),a("h2",{attrs:{id:"动态导航的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态导航的方法"}},[t._v("#")]),t._v(" 动态导航的方法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("直接使用 "),a("code",[t._v("<Link to=“” />")]),t._v(" 跳转路由。")])]),t._v(" "),a("li",[a("p",[t._v("使用 "),a("code",[t._v("withRouter")]),t._v(" 的 history, 通过 "),a("code",[t._v("this.props.history.push(obj)")]),t._v(" 跳转。")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// obj参数：")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  pathname"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/home'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 目标路由的路径")]),t._v("\n  state"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" values"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 要传的参数，不会出现在 url 中，在目标路由通过 this.props.location.state 接收")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用 history、location 或 matchs 时，需要对导出的组件包装一层 "),a("code",[t._v("withRouter")]),t._v("。或者让 props 继承自 "),a("code",[t._v("RouteProps")]),t._v("。否者会报 "),a("code",[t._v("Type '{}' is missing the following properties from type 'Readonly<RouteComponentProps<{}, StaticContext, any>>': history, location, matchts(2739)")]),t._v(" 的错误。")])]),t._v(" "),a("li",[a("p",[t._v("使用 "),a("code",[t._v("withRouter")]),t._v(" 做函数式路由导航时，需要让类组件的 props 继承 "),a("code",[t._v("RouteComponentProps")]),t._v(" 这个接口（从 "),a("code",[t._v("react-router-dom")]),t._v(" 中导入）。")])]),t._v(" "),a("li",[a("p",[t._v("如果需要在路由中使用的 Parmas 参数的话，还需要再定义一个接口 RouterInfo, 并且修改为一下")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RouterInfo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  id"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Props")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RouteComponentProps")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("RouterInfo"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("React path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'goodsList/:id.html'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("ul",[a("li",[t._v("如果链接到根路由 "),a("code",[t._v("/")]),t._v("，不要使用 "),a("code",[t._v("Link")]),t._v(" 组件，而要使用 "),a("code",[t._v("IndexLink")]),t._v(" 组件。这是因为对于根路由来说，activeStyle 和 activeClassName 会失效，或者说总是生效，因为 "),a("code",[t._v("/")]),t._v(" 会匹配任何子路由。而 "),a("code",[t._v("IndexLink")]),t._v(" 组件会使用路径的精确匹配。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("IndexLink to"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),t._v(" activeClassName"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"active"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  Home\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("IndexLink"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("另一种方法是使用 "),a("code",[t._v("Link")]),t._v("组件的 onlyActiveOnIndex 属性，也能达到同样效果。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Link to"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),t._v(" activeClassName"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"active"')]),t._v(" onlyActiveOnIndex"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  Home\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Link"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("h2",{attrs:{id:"原理解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理解析"}},[t._v("#")]),t._v(" 原理解析")]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Router")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("“xxx”")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("component")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{Home}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Router")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("在 Router 组件中，维护一个对象，包括 "),a("code",[t._v("location")]),t._v("、"),a("code",[t._v("match")]),t._v("、"),a("code",[t._v("history")]),t._v(" 等数据（正如我们在 Home 组件中可以通过 "),a("code",[t._v("this.props.history")]),t._v(" 获取到）。因为 Router 组件和 Home 组件两者关系可能是祖孙级别的，所以在 Router 组件中通过 "),a("code",[t._v("Provider")]),t._v(" 将数据传递给子孙组件、在 Route 中通过 "),a("code",[t._v("Consumer")]),t._v(" 来获取数据，再将该数据通过 prop 传递给 Home 组件。接着在 Router 组件中监听 Hash 的变化，也就是 "),a("code",[t._v("hashchange")]),t._v(" 事件（History 模式对应的是 "),a("code",[t._v("popstate")]),t._v(" 事件），在监听的回调函数中更新 "),a("code",[t._v("location")]),t._v(" 等数据。")]),t._v(" "),a("p",[t._v("在 Route 组件中，通过将 "),a("code",[t._v("this.props.path")]),t._v(" 和 "),a("code",[t._v("Consumer")]),t._v(" 接受到的 "),a("code",[t._v("pathname")]),t._v(" 进行比较，如果路径吻合的话就返回它指定的 Component，否则就返回 null，这样就可以实现根据不同的路径渲染不同的组件了。")]),t._v(" "),a("p",[t._v("比较路径的时候，单纯地通过 "),a("code",[t._v("===")]),t._v(" 或 "),a("code",[t._v("includes")]),t._v(" 匹配会有 bug。比如 "),a("code",[t._v("/home/1")]),t._v(" 和 "),a("code",[t._v("/home")]),t._v("，用 "),a("code",[t._v("===")]),t._v(" 匹配不上，用 "),a("code",[t._v("includes")]),t._v(" 匹配虽然匹配得上，但在 "),a("code",[t._v("/home/1/2")]),t._v(" 和 "),a("code",[t._v("/2")]),t._v(" 时就有 bug 了。所以需要使用正则去匹配才行，并结合 Route 的 "),a("code",[t._v("exact")]),t._v(" 和 "),a("code",[t._v("strict")]),t._v(" 属性来写正则（可以使用 path-to-regexp 这个库来根据不同的路径生成相应的正则匹配）。")])])}),[],!1,null,null,null);s.default=r.exports}}]);